{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JaxCapse","text":"[![Tests](https://github.com/CosmologicalEmulators/jaxcapse/actions/workflows/tests.yml/badge.svg)](https://github.com/CosmologicalEmulators/jaxcapse/actions/workflows/tests.yml) [![codecov](https://codecov.io/gh/CosmologicalEmulators/jaxcapse/branch/main/graph/badge.svg)](https://codecov.io/gh/CosmologicalEmulators/jaxcapse) [![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)  *Fast, differentiable CMB power spectrum emulation in JAX*"},{"location":"#overview","title":"Overview","text":"<p>JaxCapse is a JAX implementation of the CAPSE (Cosmological Autoencoder for Power Spectrum Emulation) neural network emulator for computing CMB (Cosmic Microwave Background) power spectra. It provides:</p> <ul> <li>\u26a1 Fast inference: Compute CMB power spectra in microseconds</li> <li>\ud83c\udfaf High accuracy: Sub-percent precision across a wide parameter range</li> <li>\ud83d\udd04 Automatic differentiation: Compute gradients with respect to cosmological parameters</li> <li>\ud83d\ude80 Batch processing: Efficiently process multiple parameter sets simultaneously</li> <li>\ud83d\udd27 JAX integration: Full compatibility with JAX transformations (JIT, vmap, grad)</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#speed","title":"Speed","text":"<p>JaxCapse computes CMB power spectra orders of magnitude faster than traditional Boltzmann solvers:</p> <ul> <li>Single evaluation: ~50 \u03bcs</li> <li>Gradient computation: ~400 \u03bcs</li> <li>Batch of 1000: ~10 ms</li> </ul>"},{"location":"#differentiability","title":"Differentiability","text":"<p>Leverage JAX's automatic differentiation for:</p> <ul> <li>Parameter estimation</li> <li>Fisher matrix computation</li> <li>Sensitivity analysis</li> <li>Gradient-based optimization</li> </ul>"},{"location":"#supported-spectra","title":"Supported Spectra","text":"<p>JaxCapse provides trained emulators for:</p> <ul> <li>TT: Temperature-Temperature</li> <li>EE: E-mode polarization</li> <li>TE: Temperature-E-mode cross-correlation</li> <li>PP: Lensing potential</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import jaxcapse\nimport jax.numpy as jnp\n\n# Load a trained emulator\nemulator_TT = jaxcapse.load_emulator(\"trained_emu/TT/\")\n\n# Define cosmological parameters\n# [ln10As, ns, H0, \u03c9b, \u03c9c, \u03c4]\nparams = jnp.array([3.1, 0.96, 67.0, 0.022, 0.12, 0.055])\n\n# Compute power spectrum\ncl_TT = emulator_TT.get_Cl(params)\n\n# Compute gradients\nimport jax\njacobian = jax.jacfwd(emulator_TT.get_Cl)(params)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install jaxcapse\n</code></pre> <p>Or install from source:</p> <pre><code>git clone https://github.com/CosmologicalEmulators/jaxcapse.git\ncd jaxcapse\npip install -e .\n</code></pre>"},{"location":"#documentation-contents","title":"Documentation Contents","text":"<ul> <li>Getting Started: Installation and quick start guide</li> <li>User Guide: Detailed usage instructions</li> <li>API Reference: Complete API documentation</li> <li>Examples: Code examples and tutorials</li> <li>Development: Contributing guidelines</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python \u2265 3.10</li> <li>JAX \u2265 0.4.30</li> <li>Flax \u2265 0.10.0</li> <li>jaxace \u2265 0.1.1</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use JaxCapse in your research, please cite:</p> <pre><code>@software{jaxcapse2024,\n  author = {Bonici, Marco},\n  title = {JaxCapse: JAX implementation of CAPSE emulator},\n  year = {2024},\n  url = {https://github.com/CosmologicalEmulators/jaxcapse}\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>JaxCapse is released under the MIT License. See LICENSE for details.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>JaxCapse builds on:</p> <ul> <li>jaxace: JAX implementation of AbstractCosmologicalEmulators.jl</li> <li>CAPSE: Original Julia implementation</li> <li>JAX: Composable transformations of Python+NumPy programs</li> </ul>"},{"location":"api/jaxcapse/","title":"jaxcapse","text":"<p>Main module for JaxCapse CMB power spectrum emulation.</p>"},{"location":"api/jaxcapse/#functions","title":"Functions","text":""},{"location":"api/jaxcapse/#load_emulator","title":"load_emulator","text":""},{"location":"api/jaxcapse/#jaxcapse.jaxcapse.load_emulator","title":"jaxcapse.jaxcapse.load_emulator","text":"<pre><code>load_emulator(folder_path: str) -&gt; MLP\n</code></pre> <p>Load a CAPSE emulator using jaxace infrastructure.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>Path to the emulator folder containing: - nn_setup.json: Neural network specification - weights.npy: Trained weights - inminmax.npy: Input normalization parameters - outminmax.npy: Output normalization parameters - postprocessing.py: Postprocessing function</p> required <p>Returns:</p> Type Description <code>MLP</code> <p>MLP instance ready for inference</p> Source code in <code>jaxcapse/jaxcapse.py</code> <pre><code>def load_emulator(folder_path: str) -&gt; MLP:\n    \"\"\"\n    Load a CAPSE emulator using jaxace infrastructure.\n\n    Args:\n        folder_path: Path to the emulator folder containing:\n            - nn_setup.json: Neural network specification\n            - weights.npy: Trained weights\n            - inminmax.npy: Input normalization parameters\n            - outminmax.npy: Output normalization parameters\n            - postprocessing.py: Postprocessing function\n\n    Returns:\n        MLP instance ready for inference\n    \"\"\"\n    # Ensure folder path ends with /\n    if not folder_path.endswith('/'):\n        folder_path += '/'\n\n    # Load CAPSE-specific files\n    in_MinMax = jnp.load(os.path.join(folder_path, \"inminmax.npy\"))\n    out_MinMax = jnp.load(os.path.join(folder_path, \"outminmax.npy\"))\n\n    # Load neural network configuration\n    config_path = os.path.join(folder_path, 'nn_setup.json')\n    with open(config_path, 'r') as f:\n        nn_dict = json.load(f)\n\n    # Load weights\n    weights = jnp.load(os.path.join(folder_path, \"weights.npy\"))\n\n    # Initialize jaxace emulator with the neural network\n    # jaxace now uses row-major (C) order by default, compatible with Python-trained models\n    jaxace_emulator = init_emulator(\n        nn_dict=nn_dict,\n        weight=weights,\n        validate=True  # Enable validation for safety\n    )\n\n    # Load CAPSE-specific postprocessing\n    postprocessing = load_preprocessing(folder_path, \"postprocessing\")\n\n    # Extract emulator description\n    emulator_description = nn_dict.get(\"emulator_description\", {})\n\n    # Create MLP instance with jaxace backend\n    # JIT compilation happens automatically via the @jax.jit decorator\n    return MLP(\n        emulator=jaxace_emulator,\n        in_MinMax=in_MinMax,\n        out_MinMax=out_MinMax,\n        postprocessing=postprocessing,\n        emulator_description=emulator_description\n    )\n</code></pre>"},{"location":"api/jaxcapse/#load_preprocessing","title":"load_preprocessing","text":""},{"location":"api/jaxcapse/#jaxcapse.jaxcapse.load_preprocessing","title":"jaxcapse.jaxcapse.load_preprocessing","text":"<pre><code>load_preprocessing(root_path: str, filename: str) -&gt; callable\n</code></pre> <p>Load postprocessing function from Python file.</p> <p>Parameters:</p> Name Type Description Default <code>root_path</code> <code>str</code> <p>Directory containing the postprocessing file</p> required <code>filename</code> <code>str</code> <p>Name of the postprocessing file (without .py extension)</p> required <p>Returns:</p> Type Description <code>callable</code> <p>The postprocessing function</p> Source code in <code>jaxcapse/jaxcapse.py</code> <pre><code>def load_preprocessing(root_path: str, filename: str) -&gt; callable:\n    \"\"\"\n    Load postprocessing function from Python file.\n\n    Args:\n        root_path: Directory containing the postprocessing file\n        filename: Name of the postprocessing file (without .py extension)\n\n    Returns:\n        The postprocessing function\n    \"\"\"\n    spec = importlib.util.spec_from_file_location(\n        filename,\n        os.path.join(root_path, f\"{filename}.py\")\n    )\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    return module.postprocessing\n</code></pre>"},{"location":"api/jaxcapse/#example-usage","title":"Example Usage","text":"<pre><code>import jaxcapse\nimport jax.numpy as jnp\n\n# Load an emulator\nemulator = jaxcapse.load_emulator(\"trained_emu/TT/\")\n\n# Define cosmological parameters\nparams = jnp.array([3.1, 0.96, 67.0, 0.022, 0.12, 0.055])\n\n# Compute power spectrum\ncl = emulator.get_Cl(params)\n</code></pre>"},{"location":"api/jaxcapse/#module-structure","title":"Module Structure","text":"<p>The <code>jaxcapse</code> module provides:</p> <ul> <li><code>load_emulator</code>: Main function to load trained neural network emulators</li> <li><code>load_preprocessing</code>: Utility to load postprocessing functions</li> <li><code>MLP</code>: Main emulator class (see MLP API)</li> </ul>"},{"location":"api/jaxcapse/#dependencies","title":"Dependencies","text":"<p>JaxCapse depends on:</p> <ul> <li><code>jax</code>: For automatic differentiation and JIT compilation</li> <li><code>jaxace</code>: For neural network infrastructure</li> <li><code>flax</code>: For neural network models</li> <li><code>numpy</code>: For array operations</li> </ul>"},{"location":"api/jaxcapse/#configuration","title":"Configuration","text":"<p>JaxCapse uses 64-bit precision by default:</p> <pre><code>import jax\njax.config.update('jax_enable_x64', True)\n</code></pre>"},{"location":"api/mlp/","title":"MLP Class","text":"<p>The main emulator class for computing CMB power spectra.</p>"},{"location":"api/mlp/#class-definition","title":"Class Definition","text":""},{"location":"api/mlp/#jaxcapse.jaxcapse.MLP","title":"jaxcapse.jaxcapse.MLP","text":"<pre><code>MLP(emulator: FlaxEmulator, in_MinMax: ndarray, out_MinMax: ndarray, postprocessing: callable, emulator_description: Dict[str, Any])\n</code></pre> <p>CAPSE MLP emulator using jaxace infrastructure.</p> <p>This class wraps a jaxace FlaxEmulator with CAPSE-specific functionality for CMB power spectrum computation.</p> <p>Initialize MLP with jaxace emulator and CAPSE-specific components.</p> <p>Parameters:</p> Name Type Description Default <code>emulator</code> <code>FlaxEmulator</code> <p>jaxace FlaxEmulator instance</p> required <code>in_MinMax</code> <code>ndarray</code> <p>Input normalization parameters</p> required <code>out_MinMax</code> <code>ndarray</code> <p>Output normalization parameters</p> required <code>postprocessing</code> <code>callable</code> <p>Postprocessing function (must be JAX-compatible)</p> required <code>emulator_description</code> <code>Dict[str, Any]</code> <p>Emulator metadata</p> required Source code in <code>jaxcapse/jaxcapse.py</code> <pre><code>def __init__(self,\n             emulator: FlaxEmulator,\n             in_MinMax: np.ndarray,\n             out_MinMax: np.ndarray,\n             postprocessing: callable,\n             emulator_description: Dict[str, Any]):\n    \"\"\"\n    Initialize MLP with jaxace emulator and CAPSE-specific components.\n\n    Args:\n        emulator: jaxace FlaxEmulator instance\n        in_MinMax: Input normalization parameters\n        out_MinMax: Output normalization parameters\n        postprocessing: Postprocessing function (must be JAX-compatible)\n        emulator_description: Emulator metadata\n    \"\"\"\n    self.emulator = emulator\n    self.in_MinMax = jnp.asarray(in_MinMax)  # Ensure JAX arrays for JIT\n    self.out_MinMax = jnp.asarray(out_MinMax)  # Ensure JAX arrays for JIT\n    self.postprocessing = postprocessing\n    self.emulator_description = emulator_description\n</code></pre>"},{"location":"api/mlp/#jaxcapse.jaxcapse.MLP.get_Cl","title":"get_Cl","text":"<pre><code>get_Cl(input_data: ndarray) -&gt; jnp.ndarray\n</code></pre> <p>Compute CMB power spectrum Cl values with JIT compilation.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ndarray</code> <p>Cosmological parameters as JAX array</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Processed Cl values</p> Source code in <code>jaxcapse/jaxcapse.py</code> <pre><code>@partial(jax.jit, static_argnums=(0,))\ndef get_Cl(self, input_data: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"\n    Compute CMB power spectrum Cl values with JIT compilation.\n\n    Args:\n        input_data: Cosmological parameters as JAX array\n\n    Returns:\n        Processed Cl values\n    \"\"\"\n    # Normalize input\n    norm_input = maximin(input_data, self.in_MinMax)\n\n    # Run through neural network using jaxace emulator\n    norm_output = self.emulator.run_emulator(norm_input)\n\n    # Denormalize output\n    output = inv_maximin(norm_output, self.out_MinMax)\n\n    # Apply postprocessing (assumed to be JAX-compatible)\n    processed_output = self.postprocessing(input_data, output)\n\n    return processed_output\n</code></pre>"},{"location":"api/mlp/#jaxcapse.jaxcapse.MLP.get_Cl_batch","title":"get_Cl_batch","text":"<pre><code>get_Cl_batch(input_batch: ndarray) -&gt; np.ndarray\n</code></pre> <p>Compute CMB power spectrum Cl values for a batch of inputs using vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>input_batch</code> <code>ndarray</code> <p>Array of cosmological parameters, shape (n_samples, n_params)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of processed Cl values, shape (n_samples, n_cls)</p> Source code in <code>jaxcapse/jaxcapse.py</code> <pre><code>def get_Cl_batch(self, input_batch: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Compute CMB power spectrum Cl values for a batch of inputs using vectorization.\n\n    Args:\n        input_batch: Array of cosmological parameters, shape (n_samples, n_params)\n\n    Returns:\n        Array of processed Cl values, shape (n_samples, n_cls)\n    \"\"\"\n    # Convert to JAX array\n    input_jax = jnp.asarray(input_batch)\n\n    # Vectorize the entire get_Cl function (already JIT-compiled)\n    vmap_get_Cl = jax.vmap(self.get_Cl)\n\n    # Process all inputs at once\n    return vmap_get_Cl(input_jax)\n</code></pre>"},{"location":"api/mlp/#attributes","title":"Attributes","text":""},{"location":"api/mlp/#emulator","title":"emulator","text":"<p>The underlying jaxace FlaxEmulator instance containing the neural network model.</p>"},{"location":"api/mlp/#in_minmax","title":"in_MinMax","text":"<p>JAX array of shape <code>(n_params, 2)</code> containing the minimum and maximum values for input normalization.</p>"},{"location":"api/mlp/#out_minmax","title":"out_MinMax","text":"<p>JAX array of shape <code>(n_outputs, 2)</code> containing the minimum and maximum values for output normalization.</p>"},{"location":"api/mlp/#postprocessing","title":"postprocessing","text":"<p>Callable function that applies spectrum-specific postprocessing to the neural network output.</p>"},{"location":"api/mlp/#emulator_description","title":"emulator_description","text":"<p>Dictionary containing metadata about the emulator: - <code>author</code>: Creator of the emulator - <code>author_email</code>: Contact email - <code>parameters</code>: Comma-separated list of parameter names - <code>miscellanea</code>: Additional information about training</p>"},{"location":"api/mlp/#methods","title":"Methods","text":""},{"location":"api/mlp/#get_cl","title":"get_Cl","text":"<p>Compute CMB power spectrum for a single set of cosmological parameters.</p> <p>Parameters: - <code>input_data</code> (jnp.ndarray): Cosmological parameters as JAX array of shape (n_params,)</p> <p>Returns: - <code>jnp.ndarray</code>: Power spectrum Cl values</p> <p>Example: <pre><code>params = jnp.array([3.1, 0.96, 67.0, 0.022, 0.12, 0.055])\ncl = emulator.get_Cl(params)\n</code></pre></p>"},{"location":"api/mlp/#get_cl_batch","title":"get_Cl_batch","text":"<p>Compute CMB power spectra for multiple sets of cosmological parameters.</p> <p>Parameters: - <code>input_batch</code> (np.ndarray): Array of cosmological parameters, shape (n_samples, n_params)</p> <p>Returns: - <code>np.ndarray</code>: Array of power spectra, shape (n_samples, n_cls)</p> <p>Example: <pre><code>batch_params = jnp.array([\n    [3.1, 0.96, 67.0, 0.022, 0.12, 0.055],\n    [3.0, 0.97, 68.0, 0.023, 0.11, 0.060]\n])\ncl_batch = emulator.get_Cl_batch(batch_params)\n</code></pre></p>"},{"location":"api/mlp/#jax-integration","title":"JAX Integration","text":"<p>The MLP class is fully compatible with JAX transformations:</p>"},{"location":"api/mlp/#jit-compilation","title":"JIT Compilation","text":"<p>The <code>get_Cl</code> method is JIT-compiled by default for optimal performance: <pre><code># First call includes compilation\ncl1 = emulator.get_Cl(params)  # ~1ms\n\n# Subsequent calls use compiled version\ncl2 = emulator.get_Cl(params)  # ~50\u03bcs\n</code></pre></p>"},{"location":"api/mlp/#automatic-differentiation","title":"Automatic Differentiation","text":"<pre><code>import jax\n\n# Compute gradients\ngrad_fn = jax.grad(lambda p: jnp.sum(emulator.get_Cl(p)))\ngradients = grad_fn(params)\n\n# Compute Jacobian\njacobian = jax.jacfwd(emulator.get_Cl)(params)\n</code></pre>"},{"location":"api/mlp/#vectorization","title":"Vectorization","text":"<pre><code># Vectorize for batch processing\nvmap_get_cl = jax.vmap(emulator.get_Cl)\ncl_batch = vmap_get_cl(batch_params)\n</code></pre>"},{"location":"api/mlp/#notes","title":"Notes","text":"<ul> <li>Input parameters must be JAX arrays (no automatic conversion from lists)</li> <li>The emulator uses jaxace infrastructure for neural network operations</li> <li>Normalization is handled internally using jaxace's maximin functions</li> <li>JIT compilation provides significant speedup after the first call</li> </ul>"},{"location":"api/utils/","title":"Utilities","text":"<p>Utility functions used by JaxCapse.</p>"},{"location":"api/utils/#normalization-functions","title":"Normalization Functions","text":"<p>JaxCapse uses normalization functions from jaxace:</p>"},{"location":"api/utils/#maximin","title":"maximin","text":"<p>Normalizes data to [0, 1] range using min-max scaling.</p> <pre><code>from jaxace import maximin\n\nnormalized = maximin(data, minmax_array)\n</code></pre>"},{"location":"api/utils/#inv_maximin","title":"inv_maximin","text":"<p>Inverse normalization to recover original scale.</p> <pre><code>from jaxace import inv_maximin\n\noriginal = inv_maximin(normalized_data, minmax_array)\n</code></pre>"},{"location":"api/utils/#file-structure","title":"File Structure","text":""},{"location":"api/utils/#required-files-for-emulator","title":"Required Files for Emulator","text":"<p>Each trained emulator directory must contain:</p> File Description <code>nn_setup.json</code> Neural network architecture specification <code>weights.npy</code> Trained neural network weights <code>inminmax.npy</code> Input normalization parameters <code>outminmax.npy</code> Output normalization parameters <code>postprocessing.py</code> Spectrum-specific postprocessing function"},{"location":"api/utils/#nn_setupjson-structure","title":"nn_setup.json Structure","text":"<pre><code>{\n    \"n_input_features\": 6,\n    \"n_output_features\": 4999,\n    \"n_hidden_layers\": 3,\n    \"layers\": {\n        \"layer_1\": {\n            \"n_neurons\": 256,\n            \"activation_function\": \"tanh\"\n        },\n        \"layer_2\": {\n            \"n_neurons\": 256,\n            \"activation_function\": \"tanh\"\n        },\n        \"layer_3\": {\n            \"n_neurons\": 128,\n            \"activation_function\": \"relu\"\n        }\n    },\n    \"emulator_description\": {\n        \"author\": \"Marco Bonici\",\n        \"author_email\": \"bonici.marco@gmail.com\",\n        \"parameters\": \"ln10As, ns, H0, \u03c9b, \u03c9c, \u03c4\",\n        \"miscellanea\": \"Trained on CAMB predictions\"\n    }\n}\n</code></pre>"},{"location":"api/utils/#postprocessing-function","title":"Postprocessing Function","text":"<p>The postprocessing function must have the signature:</p> <pre><code>def postprocessing(input_params, output):\n    \"\"\"\n    Apply spectrum-specific postprocessing.\n\n    Args:\n        input_params: Cosmological parameters (JAX array)\n        output: Neural network output (JAX array)\n\n    Returns:\n        Processed power spectrum values\n    \"\"\"\n    import jax.numpy as jnp\n    return output * jnp.exp(input_params[0] - 3.0)\n</code></pre>"},{"location":"api/utils/#jax-configuration","title":"JAX Configuration","text":""},{"location":"api/utils/#precision-settings","title":"Precision Settings","text":"<p>JaxCapse uses 64-bit precision by default:</p> <pre><code>import jax\njax.config.update('jax_enable_x64', True)\n</code></pre>"},{"location":"api/utils/#device-selection","title":"Device Selection","text":"<p>Check available devices:</p> <pre><code>import jax\nprint(jax.devices())  # Lists available devices\n</code></pre> <p>Force CPU usage:</p> <pre><code>import os\nos.environ['JAX_PLATFORM_NAME'] = 'cpu'\n</code></pre>"},{"location":"api/utils/#error-handling","title":"Error Handling","text":""},{"location":"api/utils/#common-errors-and-solutions","title":"Common Errors and Solutions","text":"Error Cause Solution <code>FileNotFoundError</code> Missing emulator files Ensure all required files are in the directory <code>AttributeError: 'list' object has no attribute 'ndim'</code> Passing list instead of array Convert to JAX array: <code>jnp.array(params)</code> <code>ValueError: shapes do not match</code> Wrong number of parameters Check parameter order and count <code>json.JSONDecodeError</code> Corrupted nn_setup.json Verify JSON file is valid"},{"location":"api/utils/#performance-tips","title":"Performance Tips","text":""},{"location":"api/utils/#jit-compilation","title":"JIT Compilation","text":"<ul> <li>First call compiles the function (slower)</li> <li>Subsequent calls use compiled version (faster)</li> <li>Compilation is shape-specific</li> </ul>"},{"location":"api/utils/#memory-management","title":"Memory Management","text":"<p>For large batches: <pre><code># Process in chunks if needed\nchunk_size = 1000\nresults = []\nfor i in range(0, len(large_batch), chunk_size):\n    chunk = large_batch[i:i+chunk_size]\n    results.append(emulator.get_Cl_batch(chunk))\nresult = jnp.concatenate(results)\n</code></pre></p>"},{"location":"api/utils/#gradient-computation","title":"Gradient Computation","text":"<p>For many outputs, use forward-mode differentiation: <pre><code># Efficient for n_outputs &gt;&gt; n_inputs\njacobian = jax.jacfwd(emulator.get_Cl)(params)\n</code></pre></p> <p>For many inputs, use reverse-mode: <pre><code># Efficient for n_inputs &gt;&gt; n_outputs\njacobian = jax.jacrev(emulator.get_Cl)(params)\n</code></pre></p>"},{"location":"development/changelog/","title":"Changelog","text":"<p>All notable changes to JaxCapse will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"development/changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"development/changelog/#added","title":"Added","text":"<ul> <li>Comprehensive unit test suite with 100% coverage</li> <li>MkDocs documentation with Material theme</li> <li>GitHub Actions CI/CD pipeline</li> <li>Support for Python 3.10, 3.11, 3.12</li> <li>Test fixtures for mock emulators</li> <li>Edge case testing</li> <li>JAX feature tests (gradients, vmap, JIT)</li> </ul>"},{"location":"development/changelog/#changed","title":"Changed","text":"<ul> <li>Removed backward compatibility features</li> <li>Removed wrapper methods (maximin_input, inv_maximin_output, apply)</li> <li>Enforced JAX array inputs (no automatic list conversion)</li> <li>Simplified API surface</li> </ul>"},{"location":"development/changelog/#fixed","title":"Fixed","text":"<ul> <li>Improved error handling for missing files</li> <li>Better validation of input parameters</li> </ul>"},{"location":"development/changelog/#011-2024-01-15","title":"[0.1.1] - 2024-01-15","text":""},{"location":"development/changelog/#added_1","title":"Added","text":"<ul> <li>Initial public release</li> <li>Core MLP emulator class</li> <li>Support for TT, EE, TE, PP spectra</li> <li>Batch processing capability</li> <li>JAX integration (JIT, grad, vmap)</li> <li>Basic documentation</li> </ul>"},{"location":"development/changelog/#dependencies","title":"Dependencies","text":"<ul> <li>JAX &gt;= 0.4.30</li> <li>Flax &gt;= 0.10.0</li> <li>jaxace &gt;= 0.1.1</li> </ul>"},{"location":"development/changelog/#010-2024-01-01","title":"[0.1.0] - 2024-01-01","text":""},{"location":"development/changelog/#added_2","title":"Added","text":"<ul> <li>Initial implementation</li> <li>Basic emulator loading</li> <li>Power spectrum computation</li> </ul>"},{"location":"development/changelog/#version-history","title":"Version History","text":""},{"location":"development/changelog/#versioning-scheme","title":"Versioning Scheme","text":"<p>JaxCapse follows Semantic Versioning:</p> <ul> <li>MAJOR version for incompatible API changes</li> <li>MINOR version for added functionality (backward compatible)</li> <li>PATCH version for backward compatible bug fixes</li> </ul>"},{"location":"development/changelog/#deprecation-policy","title":"Deprecation Policy","text":"<ul> <li>Deprecated features are marked with warnings</li> <li>Deprecated features are removed in next MAJOR version</li> <li>Migration guides provided for breaking changes</li> </ul>"},{"location":"development/changelog/#support-policy","title":"Support Policy","text":"<ul> <li>Latest version: Full support</li> <li>Previous minor version: Security fixes only</li> <li>Older versions: No support</li> </ul>"},{"location":"development/changelog/#roadmap","title":"Roadmap","text":""},{"location":"development/changelog/#planned-features","title":"Planned Features","text":""},{"location":"development/changelog/#version-020","title":"Version 0.2.0","text":"<ul> <li>[ ] Support for massive neutrinos</li> <li>[ ] Extended \u2113 range (up to 10000)</li> <li>[ ] Additional cosmological parameters</li> </ul>"},{"location":"development/changelog/#version-030","title":"Version 0.3.0","text":"<ul> <li>[ ] Non-linear corrections</li> <li>[ ] Cross-correlation with LSS</li> <li>[ ] Fisher matrix utilities</li> </ul>"},{"location":"development/changelog/#version-100","title":"Version 1.0.0","text":"<ul> <li>[ ] Stable API</li> <li>[ ] Complete documentation</li> <li>[ ] Performance optimizations</li> <li>[ ] GPU optimization</li> </ul>"},{"location":"development/changelog/#known-issues","title":"Known Issues","text":"<ul> <li>No support for non-flat cosmologies</li> <li>Limited to \u039bCDM model</li> <li>Fixed neutrino masses</li> <li>No BAO/RSD emulation</li> </ul>"},{"location":"development/changelog/#reporting-issues","title":"Reporting Issues","text":"<p>Report issues at: https://github.com/CosmologicalEmulators/jaxcapse/issues</p>"},{"location":"development/changelog/#contributors","title":"Contributors","text":"<ul> <li>Marco Bonici (@marcobonici) - Creator and maintainer</li> </ul>"},{"location":"development/changelog/#acknowledgments","title":"Acknowledgments","text":"<ul> <li>jaxace developers for neural network infrastructure</li> <li>JAX team for automatic differentiation framework</li> <li>CAMB/CLASS for training data generation</li> </ul>"},{"location":"development/contributing/","title":"Contributing to JaxCapse","text":"<p>We welcome contributions to JaxCapse! This guide explains how to contribute.</p>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":""},{"location":"development/contributing/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone https://github.com/CosmologicalEmulators/jaxcapse.git\ncd jaxcapse\n</code></pre>"},{"location":"development/contributing/#install-development-dependencies","title":"Install Development Dependencies","text":"<pre><code># Using Poetry (recommended)\npoetry install --with dev --with docs\n\n# Or using pip\npip install -e \".[dev,docs]\"\n</code></pre>"},{"location":"development/contributing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Set up pre-commit hooks for code quality:</p> <pre><code>pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"development/contributing/#code-style","title":"Code Style","text":""},{"location":"development/contributing/#python-style","title":"Python Style","text":"<ul> <li>Follow PEP 8</li> <li>Use type hints where appropriate</li> <li>Maximum line length: 100 characters</li> <li>Use descriptive variable names</li> </ul>"},{"location":"development/contributing/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings:</p> <pre><code>def function(param1: float, param2: jnp.ndarray) -&gt; jnp.ndarray:\n    \"\"\"Brief description of function.\n\n    Longer description if needed.\n\n    Args:\n        param1: Description of param1.\n        param2: Description of param2.\n\n    Returns:\n        Description of return value.\n\n    Example:\n        &gt;&gt;&gt; result = function(1.0, jnp.array([1, 2, 3]))\n    \"\"\"\n</code></pre>"},{"location":"development/contributing/#testing","title":"Testing","text":""},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npoetry run pytest tests/\n\n# Run with coverage\npoetry run pytest tests/ --cov=jaxcapse --cov-report=html\n\n# Run specific test file\npoetry run pytest tests/test_core_functionality.py\n\n# Run in parallel\npoetry run pytest tests/ -n auto\n</code></pre>"},{"location":"development/contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Place tests in <code>tests/</code> directory</li> <li>Name test files <code>test_*.py</code></li> <li>Focus on software functionality, not cosmology</li> <li>Use fixtures from <code>tests/fixtures.py</code></li> </ul> <p>Example test:</p> <pre><code>def test_emulator_loading(mock_emulator_directory):\n    \"\"\"Test that emulator loads correctly.\"\"\"\n    emulator = jaxcapse.load_emulator(str(mock_emulator_directory))\n    assert isinstance(emulator, jaxcapse.MLP)\n    assert emulator.emulator is not None\n</code></pre>"},{"location":"development/contributing/#test-coverage","title":"Test Coverage","text":"<p>Maintain test coverage above 85%:</p> <pre><code>poetry run pytest tests/ --cov=jaxcapse --cov-report=term-missing\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":""},{"location":"development/contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Build locally\npoetry run mkdocs serve\n\n# Build static site\npoetry run mkdocs build\n</code></pre>"},{"location":"development/contributing/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use Markdown for all documentation</li> <li>Include code examples</li> <li>Update API docs for new functions</li> <li>Add usage examples for new features</li> </ul>"},{"location":"development/contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"development/contributing/#1-fork-and-branch","title":"1. Fork and Branch","text":"<pre><code># Fork repository on GitHub\ngit clone https://github.com/YOUR_USERNAME/jaxcapse.git\ncd jaxcapse\ngit checkout -b feature/your-feature-name\n</code></pre>"},{"location":"development/contributing/#2-make-changes","title":"2. Make Changes","text":"<ul> <li>Write code following style guidelines</li> <li>Add tests for new functionality</li> <li>Update documentation</li> <li>Ensure all tests pass</li> </ul>"},{"location":"development/contributing/#3-commit-changes","title":"3. Commit Changes","text":"<pre><code># Stage changes\ngit add .\n\n# Commit with descriptive message\ngit commit -m \"Add feature: description of changes\"\n</code></pre>"},{"location":"development/contributing/#4-push-and-create-pr","title":"4. Push and Create PR","text":"<pre><code># Push to your fork\ngit push origin feature/your-feature-name\n</code></pre> <p>Then create a pull request on GitHub.</p>"},{"location":"development/contributing/#pull-request-checklist","title":"Pull Request Checklist","text":"<ul> <li>[ ] Tests pass (<code>pytest tests/</code>)</li> <li>[ ] Code follows style guidelines</li> <li>[ ] Documentation updated</li> <li>[ ] Changelog updated</li> <li>[ ] Type hints added</li> <li>[ ] Docstrings complete</li> </ul>"},{"location":"development/contributing/#issue-reporting","title":"Issue Reporting","text":""},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>Include: - JaxCapse version - Python version - JAX version - Minimal reproducible example - Error messages - Expected behavior</p>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>Include: - Use case description - Proposed API - Example code - Alternatives considered</p>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#adding-a-new-feature","title":"Adding a New Feature","text":"<ol> <li>Discuss: Open an issue to discuss the feature</li> <li>Design: Propose API and implementation</li> <li>Implement: Write code with tests</li> <li>Document: Update docs and examples</li> <li>Review: Submit PR for review</li> </ol>"},{"location":"development/contributing/#fixing-a-bug","title":"Fixing a Bug","text":"<ol> <li>Report: Open issue with bug details</li> <li>Test: Write failing test that reproduces bug</li> <li>Fix: Implement fix</li> <li>Verify: Ensure test passes</li> <li>Submit: Create PR with fix</li> </ol>"},{"location":"development/contributing/#release-process","title":"Release Process","text":""},{"location":"development/contributing/#version-numbering","title":"Version Numbering","text":"<p>We use semantic versioning (MAJOR.MINOR.PATCH):</p> <ul> <li>MAJOR: Breaking API changes</li> <li>MINOR: New features (backward compatible)</li> <li>PATCH: Bug fixes</li> </ul>"},{"location":"development/contributing/#release-steps","title":"Release Steps","text":"<ol> <li>Update version in <code>pyproject.toml</code></li> <li>Update CHANGELOG.md</li> <li>Create git tag: <code>git tag v0.2.0</code></li> <li>Push tag: <code>git push origin v0.2.0</code></li> <li>GitHub Actions builds and publishes</li> </ol>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive</li> <li>Welcome newcomers</li> <li>Focus on constructive criticism</li> <li>Respect differing opinions</li> <li>Accept responsibility for mistakes</li> </ul>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>Discussions: General questions and ideas</li> <li>Email: Contact maintainers directly</li> </ul>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in: - CHANGELOG.md - GitHub contributors page - Documentation acknowledgments</p> <p>Thank you for contributing to JaxCapse!</p>"},{"location":"development/testing/","title":"Testing Guide","text":""},{"location":"development/testing/#running-tests","title":"Running Tests","text":""},{"location":"development/testing/#quick-start","title":"Quick Start","text":"<pre><code># Run all tests\npoetry run pytest tests/\n\n# Run with coverage\npoetry run pytest tests/ --cov=jaxcapse\n\n# Run specific test file\npoetry run pytest tests/test_core_functionality.py\n</code></pre>"},{"location":"development/testing/#test-coverage","title":"Test Coverage","text":"<p>Current coverage: 100% (47/47 lines)</p> <pre><code># Generate coverage report\npoetry run pytest tests/ --cov=jaxcapse --cov-report=html\n# Open htmlcov/index.html in browser\n</code></pre>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":""},{"location":"development/testing/#test-files","title":"Test Files","text":"File Purpose Tests <code>test_core_functionality.py</code> Core MLP functionality 13 <code>test_inference.py</code> Inference and batching 15 <code>test_edge_cases.py</code> Error handling 13 <code>test_jax_features.py</code> JAX transformations 12 <code>test_utils.py</code> Utility functions 7"},{"location":"development/testing/#test-categories","title":"Test Categories","text":"<ol> <li>Unit Tests: Individual function testing</li> <li>Integration Tests: End-to-end workflows</li> <li>Edge Cases: Boundary conditions and errors</li> <li>Performance Tests: Speed and memory usage</li> </ol>"},{"location":"development/testing/#writing-tests","title":"Writing Tests","text":""},{"location":"development/testing/#test-guidelines","title":"Test Guidelines","text":"<ul> <li>Focus on software functionality, not cosmology</li> <li>Use fixtures from <code>tests/fixtures.py</code></li> <li>Keep tests fast (&lt; 1 second each)</li> <li>Test both success and failure cases</li> <li>Use descriptive test names</li> </ul>"},{"location":"development/testing/#example-test","title":"Example Test","text":"<pre><code>def test_emulator_loading(mock_emulator_directory):\n    \"\"\"Test that emulator loads correctly.\"\"\"\n    emulator = jaxcapse.load_emulator(str(mock_emulator_directory))\n\n    # Check correct type\n    assert isinstance(emulator, jaxcapse.MLP)\n\n    # Check attributes exist\n    assert emulator.emulator is not None\n    assert emulator.in_MinMax is not None\n    assert emulator.out_MinMax is not None\n</code></pre>"},{"location":"development/testing/#using-fixtures","title":"Using Fixtures","text":"<pre><code>from tests.fixtures import *\n\ndef test_with_mock_emulator(mock_emulator_directory):\n    \"\"\"Test using mock emulator fixture.\"\"\"\n    emulator = jaxcapse.load_emulator(str(mock_emulator_directory))\n    # Test code here\n</code></pre>"},{"location":"development/testing/#continuous-integration","title":"Continuous Integration","text":"<p>Tests run automatically on: - Push to main/develop branches - Pull requests - Python 3.10, 3.11, 3.12 - Ubuntu and macOS</p>"},{"location":"development/testing/#ci-workflow","title":"CI Workflow","text":"<pre><code># .github/workflows/tests.yml\n- Run tests with pytest\n- Generate coverage report\n- Upload to codecov (optional)\n- Run linting checks\n</code></pre>"},{"location":"development/testing/#test-commands","title":"Test Commands","text":""},{"location":"development/testing/#common-commands","title":"Common Commands","text":"<pre><code># Run all tests verbose\npoetry run pytest tests/ -v\n\n# Run with specific marker\npoetry run pytest tests/ -m \"not slow\"\n\n# Run in parallel\npoetry run pytest tests/ -n auto\n\n# Run with warnings\npoetry run pytest tests/ -W error\n\n# Debug failed test\npoetry run pytest tests/ --pdb\n</code></pre>"},{"location":"development/testing/#coverage-commands","title":"Coverage Commands","text":"<pre><code># Terminal report\npoetry run pytest tests/ --cov=jaxcapse --cov-report=term-missing\n\n# HTML report\npoetry run pytest tests/ --cov=jaxcapse --cov-report=html\n\n# XML for CI\npoetry run pytest tests/ --cov=jaxcapse --cov-report=xml\n</code></pre>"},{"location":"development/testing/#debugging-tests","title":"Debugging Tests","text":""},{"location":"development/testing/#print-debugging","title":"Print Debugging","text":"<pre><code>def test_with_debugging(capsys):\n    \"\"\"Test with print debugging.\"\"\"\n    result = some_function()\n\n    # Capture print output\n    captured = capsys.readouterr()\n    print(f\"Debug: result = {result}\")\n\n    assert result == expected\n</code></pre>"},{"location":"development/testing/#using-pdb","title":"Using pdb","text":"<pre><code>def test_with_pdb():\n    \"\"\"Test with debugger.\"\"\"\n    import pdb; pdb.set_trace()\n    # Debugger stops here\n    result = complex_function()\n    assert result == expected\n</code></pre>"},{"location":"development/testing/#jax-debugging","title":"JAX Debugging","text":"<pre><code># Disable JIT for debugging\nimport jax\njax.config.update('jax_disable_jit', True)\n\n# Enable NaN checking\njax.config.update('jax_debug_nans', True)\n</code></pre>"},{"location":"development/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"development/testing/#timing-tests","title":"Timing Tests","text":"<pre><code>def test_performance(benchmark):\n    \"\"\"Test with pytest-benchmark.\"\"\"\n    result = benchmark(emulator.get_Cl, params)\n    assert result is not None\n</code></pre>"},{"location":"development/testing/#memory-testing","title":"Memory Testing","text":"<pre><code>import tracemalloc\n\ndef test_memory_usage():\n    \"\"\"Test memory consumption.\"\"\"\n    tracemalloc.start()\n\n    # Run operation\n    result = process_large_batch(data)\n\n    current, peak = tracemalloc.get_traced_memory()\n    tracemalloc.stop()\n\n    # Check memory usage\n    assert peak &lt; 1_000_000_000  # Less than 1GB\n</code></pre>"},{"location":"development/testing/#test-data","title":"Test Data","text":""},{"location":"development/testing/#mock-data","title":"Mock Data","text":"<p>Use fixtures for consistent test data:</p> <pre><code>@pytest.fixture\ndef sample_cosmological_params():\n    \"\"\"Standard test parameters.\"\"\"\n    return np.array([3.1, 0.96, 67.0, 0.022, 0.12, 0.055])\n</code></pre>"},{"location":"development/testing/#real-data","title":"Real Data","text":"<p>For integration tests with real emulators:</p> <pre><code>def test_real_emulator():\n    \"\"\"Test with actual trained emulator.\"\"\"\n    if not Path(\"trained_emu/TT\").exists():\n        pytest.skip(\"Real emulator not available\")\n\n    emulator = jaxcapse.load_emulator(\"trained_emu/TT/\")\n    # Test with real emulator\n</code></pre>"},{"location":"development/testing/#best-practices","title":"Best Practices","text":"<ol> <li>Isolation: Tests should not depend on each other</li> <li>Repeatability: Use fixed seeds for randomness</li> <li>Clarity: Clear test names and docstrings</li> <li>Coverage: Aim for &gt;85% code coverage</li> <li>Speed: Keep test suite under 30 seconds</li> </ol>"},{"location":"development/testing/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/testing/#common-issues","title":"Common Issues","text":"Issue Solution Import errors Check PYTHONPATH and installation Fixture not found Import from <code>tests.fixtures</code> Tests slow Use pytest-xdist for parallel execution Coverage low Add tests for uncovered lines"},{"location":"development/testing/#getting-help","title":"Getting Help","text":"<ul> <li>Check existing tests for examples</li> <li>Review pytest documentation</li> <li>Open GitHub issue for bugs</li> </ul>"},{"location":"examples/basic/","title":"Basic Usage Examples","text":""},{"location":"examples/basic/#simple-power-spectrum-computation","title":"Simple Power Spectrum Computation","text":"<pre><code>import jaxcapse\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\n# Load emulator\nemulator = jaxcapse.load_emulator(\"trained_emu/TT/\")\n\n# Define cosmological parameters\nparams = jnp.array([3.1, 0.96, 67.0, 0.022, 0.12, 0.055])\n\n# Compute power spectrum\ncl = emulator.get_Cl(params)\n\n# Plot\nell = jnp.arange(2, len(cl) + 2)\nplt.figure(figsize=(8, 5))\nplt.plot(ell, ell * (ell + 1) * cl / (2 * jnp.pi))\nplt.xlabel(r'$\\ell$')\nplt.ylabel(r'$D_\\ell^{TT}$ [$\\mu K^2$]')\nplt.show()\n</code></pre>"},{"location":"examples/basic/#parameter-variations","title":"Parameter Variations","text":"<pre><code># Vary one parameter\nns_values = jnp.linspace(0.92, 1.00, 5)\nresults = []\n\nfor ns in ns_values:\n    params_varied = params.at[1].set(ns)\n    cl = emulator.get_Cl(params_varied)\n    results.append(cl)\n\n# Plot variations\nfor i, (ns, cl) in enumerate(zip(ns_values, results)):\n    plt.plot(ell, cl, label=f'ns={ns:.2f}')\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"examples/batch/","title":"Batch Processing Examples","text":""},{"location":"examples/batch/#processing-multiple-cosmologies","title":"Processing Multiple Cosmologies","text":"<pre><code>import jaxcapse\nimport jax.numpy as jnp\nimport jax\n\n# Load emulator\nemulator = jaxcapse.load_emulator(\"trained_emu/TT/\")\n\n# Generate random cosmologies\nkey = jax.random.PRNGKey(42)\nn_samples = 100\n\n# Random variations around fiducial\nfiducial = jnp.array([3.05, 0.965, 67.36, 0.0224, 0.120, 0.054])\nvariations = jax.random.normal(key, (n_samples, 6)) * 0.01\nbatch_params = fiducial + variations\n\n# Process batch\ncl_batch = emulator.get_Cl_batch(batch_params)\n\n# Compute statistics\nmean_cl = jnp.mean(cl_batch, axis=0)\nstd_cl = jnp.std(cl_batch, axis=0)\n\nprint(f\"Processed {n_samples} cosmologies\")\nprint(f\"Mean Cl shape: {mean_cl.shape}\")\n</code></pre>"},{"location":"examples/batch/#mcmc-sampling","title":"MCMC Sampling","text":"<pre><code>def log_likelihood(params, data, emulator):\n    \"\"\"Compute log likelihood for MCMC.\"\"\"\n    cl_theory = emulator.get_Cl(params)\n    chi2 = jnp.sum((cl_theory - data['cl'])**2 / data['variance'])\n    return -0.5 * chi2\n\n# Use in MCMC sampler\n# (example with emcee or other samplers)\n</code></pre>"},{"location":"examples/gradients/","title":"Gradient Examples","text":""},{"location":"examples/gradients/#computing-derivatives","title":"Computing Derivatives","text":"<pre><code>import jax\nimport jax.numpy as jnp\nimport jaxcapse\n\n# Load emulator\nemulator = jaxcapse.load_emulator(\"trained_emu/TT/\")\nparams = jnp.array([3.1, 0.96, 67.0, 0.022, 0.12, 0.055])\n\n# Gradient of sum of Cl\ngrad_fn = jax.grad(lambda p: jnp.sum(emulator.get_Cl(p)))\ngradients = grad_fn(params)\n\nprint(\"Parameter gradients:\", gradients)\n</code></pre>"},{"location":"examples/gradients/#fisher-matrix","title":"Fisher Matrix","text":"<pre><code># Compute Jacobian\njacobian = jax.jacfwd(emulator.get_Cl)(params)\n\n# Compute Fisher matrix (simplified)\ncl = emulator.get_Cl(params)\nell = jnp.arange(2, len(cl) + 2)\nvariance = 2 * cl**2 / (2*ell + 1)\n\nfisher = jnp.zeros((6, 6))\nfor l in range(len(cl)):\n    fisher += jnp.outer(jacobian[l], jacobian[l]) / variance[l]\n\nprint(\"Fisher matrix shape:\", fisher.shape)\n</code></pre>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#requirements","title":"Requirements","text":"<p>JaxCapse requires Python 3.10 or later. The main dependencies are:</p> <ul> <li>JAX \u2265 0.4.30</li> <li>Flax \u2265 0.10.0</li> <li>jaxace \u2265 0.1.1</li> <li>NumPy</li> </ul>"},{"location":"getting_started/installation/#install-from-pypi","title":"Install from PyPI","text":"<p>The simplest way to install JaxCapse is via pip:</p> <pre><code>pip install jaxcapse\n</code></pre>"},{"location":"getting_started/installation/#install-from-source","title":"Install from Source","text":"<p>For the latest development version, install directly from GitHub:</p> <pre><code>git clone https://github.com/CosmologicalEmulators/jaxcapse.git\ncd jaxcapse\npip install -e .\n</code></pre>"},{"location":"getting_started/installation/#install-with-poetry","title":"Install with Poetry","text":"<p>If you're using Poetry for dependency management:</p> <pre><code>git clone https://github.com/CosmologicalEmulators/jaxcapse.git\ncd jaxcapse\npoetry install\n</code></pre>"},{"location":"getting_started/installation/#gpu-support","title":"GPU Support","text":"<p>JaxCapse automatically uses GPU acceleration if available. To install JAX with GPU support:</p>"},{"location":"getting_started/installation/#cuda-118","title":"CUDA 11.8","text":"<pre><code>pip install --upgrade \"jax[cuda11_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html\n</code></pre>"},{"location":"getting_started/installation/#cuda-12","title":"CUDA 12","text":"<pre><code>pip install --upgrade \"jax[cuda12_pip]\" -f https://storage.googleapis.com/jax-releases/jax_cuda_releases.html\n</code></pre>"},{"location":"getting_started/installation/#verify-installation","title":"Verify Installation","text":"<p>To verify that JaxCapse is correctly installed:</p> <pre><code>import jaxcapse\nimport jax\n\nprint(f\"JaxCapse version: {jaxcapse.__version__}\")\nprint(f\"JAX version: {jax.__version__}\")\nprint(f\"Device: {jax.devices()[0]}\")\n</code></pre>"},{"location":"getting_started/installation/#getting-trained-emulators","title":"Getting Trained Emulators","text":"<p>JaxCapse requires trained neural network weights to function. You can:</p> <ol> <li> <p>Download pre-trained emulators from the JaxCapse repository</p> </li> <li> <p>Train your own emulators using the training scripts (see Development Guide)</p> </li> </ol> <p>Example structure for trained emulators: <pre><code>trained_emu/\n\u251c\u2500\u2500 TT/\n\u2502   \u251c\u2500\u2500 nn_setup.json\n\u2502   \u251c\u2500\u2500 weights.npy\n\u2502   \u251c\u2500\u2500 inminmax.npy\n\u2502   \u251c\u2500\u2500 outminmax.npy\n\u2502   \u2514\u2500\u2500 postprocessing.py\n\u251c\u2500\u2500 EE/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 TE/\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 PP/\n    \u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"getting_started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting_started/installation/#importerror-no-module-named-jaxcapse","title":"ImportError: No module named 'jaxcapse'","text":"<p>Make sure you've installed JaxCapse in your current Python environment: <pre><code>pip show jaxcapse\n</code></pre></p>"},{"location":"getting_started/installation/#jax-not-using-gpu","title":"JAX not using GPU","text":"<p>Verify JAX can see your GPU: <pre><code>import jax\nprint(jax.devices())  # Should show GPU device\n</code></pre></p> <p>If not, reinstall JAX with the appropriate CUDA version.</p>"},{"location":"getting_started/installation/#memory-errors-with-large-batches","title":"Memory errors with large batches","text":"<p>JaxCapse is memory-efficient, but very large batches may exceed GPU memory. Try:</p> <ul> <li>Reducing batch size</li> <li>Using CPU for extremely large batches</li> <li>Processing in chunks</li> </ul>"},{"location":"getting_started/installation/#next-steps","title":"Next Steps","text":"<p>Once installed, proceed to the Quick Start guide to begin using JaxCapse.</p>"},{"location":"getting_started/quickstart/","title":"Quick Start","text":"<p>This guide will get you computing CMB power spectra with JaxCapse in minutes.</p>"},{"location":"getting_started/quickstart/#basic-usage","title":"Basic Usage","text":""},{"location":"getting_started/quickstart/#1-import-jaxcapse","title":"1. Import JaxCapse","text":"<pre><code>import jaxcapse\nimport jax.numpy as jnp\n</code></pre>"},{"location":"getting_started/quickstart/#2-load-an-emulator","title":"2. Load an Emulator","text":"<pre><code># Load the temperature-temperature (TT) emulator\nemulator_TT = jaxcapse.load_emulator(\"trained_emu/TT/\")\n</code></pre>"},{"location":"getting_started/quickstart/#3-check-emulator-information","title":"3. Check Emulator Information","text":"<pre><code># View emulator description\nprint(emulator_TT.emulator_description)\n</code></pre> <p>Output: <pre><code>{\n    'author': 'Marco Bonici',\n    'author_email': 'bonici.marco@gmail.com',\n    'parameters': 'ln10As, ns, H0, \u03c9b, \u03c9c, \u03c4',\n    'miscellanea': 'Trained on CAMB high-precision predictions'\n}\n</code></pre></p>"},{"location":"getting_started/quickstart/#4-define-cosmological-parameters","title":"4. Define Cosmological Parameters","text":"<p>The parameters must be provided in the order specified by the emulator:</p> <pre><code># Parameters: [ln10As, ns, H0, \u03c9b, \u03c9c, \u03c4]\nparams = jnp.array([\n    3.1,    # ln(10^10 As)\n    0.96,   # Spectral index\n    67.0,   # Hubble constant [km/s/Mpc]\n    0.022,  # Physical baryon density\n    0.12,   # Physical CDM density\n    0.055   # Optical depth to reionization\n])\n</code></pre>"},{"location":"getting_started/quickstart/#5-compute-power-spectrum","title":"5. Compute Power Spectrum","text":"<pre><code># Compute Cl values\ncl_TT = emulator_TT.get_Cl(params)\n\nprint(f\"Shape: {cl_TT.shape}\")\nprint(f\"First 5 values: {cl_TT[:5]}\")\n</code></pre>"},{"location":"getting_started/quickstart/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that loads all four emulators and computes all spectra:</p> <pre><code>import jaxcapse\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\n# Load all emulators\nemulators = {\n    'TT': jaxcapse.load_emulator(\"trained_emu/TT/\"),\n    'EE': jaxcapse.load_emulator(\"trained_emu/EE/\"),\n    'TE': jaxcapse.load_emulator(\"trained_emu/TE/\"),\n    'PP': jaxcapse.load_emulator(\"trained_emu/PP/\")\n}\n\n# Define cosmological parameters\nparams = jnp.array([3.1, 0.96, 67.0, 0.022, 0.12, 0.055])\n\n# Compute all spectra\nspectra = {}\nfor name, emulator in emulators.items():\n    spectra[name] = emulator.get_Cl(params)\n\n# Plot results\nfig, axes = plt.subplots(2, 2, figsize=(10, 8))\nell = jnp.arange(2, len(spectra['TT']) + 2)\n\nfor ax, (name, cl) in zip(axes.flat, spectra.items()):\n    ax.plot(ell, cl)\n    ax.set_xlabel(r'$\\ell$')\n    ax.set_ylabel(f'$C_\\\\ell^{{{name}}}$')\n    ax.set_title(f'{name} Spectrum')\n    if name == 'PP':\n        ax.set_yscale('log')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"getting_started/quickstart/#performance-timing","title":"Performance Timing","text":"<p>Check the speed of JaxCapse:</p> <pre><code>import time\n\n# Time single evaluation\nstart = time.perf_counter()\ncl = emulator_TT.get_Cl(params)\nend = time.perf_counter()\nprint(f\"Single evaluation: {(end - start)*1e6:.1f} \u03bcs\")\n\n# Time after JIT compilation (second call)\nstart = time.perf_counter()\ncl = emulator_TT.get_Cl(params)\nend = time.perf_counter()\nprint(f\"After JIT: {(end - start)*1e6:.1f} \u03bcs\")\n</code></pre>"},{"location":"getting_started/quickstart/#parameter-ranges","title":"Parameter Ranges","text":"<p>Each emulator is trained on specific parameter ranges. Check the training bounds:</p> <pre><code># View input parameter bounds\nprint(\"Parameter ranges:\")\nprint(emulator_TT.in_MinMax)\n</code></pre> <p>The bounds are given as <code>[min, max]</code> for each parameter: - ln10As: [2.5, 3.5] - ns: [0.88, 1.05] - H0: [40, 100] - \u03c9b: [0.019, 0.025] - \u03c9c: [0.08, 0.20] - \u03c4: [0.02, 0.12]</p> <p>Stay Within Training Bounds</p> <p>For accurate results, keep parameters within the training ranges. The emulator may produce unreliable outputs for parameters outside these bounds.</p>"},{"location":"getting_started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about computing gradients</li> <li>Explore batch processing</li> <li>See the detailed tutorial</li> </ul>"},{"location":"getting_started/tutorial/","title":"Tutorial","text":"<p>This tutorial provides a comprehensive introduction to JaxCapse, covering basic usage through advanced features.</p>"},{"location":"getting_started/tutorial/#part-1-basic-power-spectrum-computation","title":"Part 1: Basic Power Spectrum Computation","text":""},{"location":"getting_started/tutorial/#setting-up","title":"Setting Up","text":"<pre><code>import jaxcapse\nimport jax\nimport jax.numpy as jnp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Configure JAX for 64-bit precision\njax.config.update('jax_enable_x64', True)\n</code></pre>"},{"location":"getting_started/tutorial/#loading-and-exploring-emulators","title":"Loading and Exploring Emulators","text":"<pre><code># Load the TT emulator\nemulator_TT = jaxcapse.load_emulator(\"trained_emu/TT/\")\n\n# Examine the emulator structure\nprint(\"Emulator attributes:\")\nprint(f\"- Input normalization shape: {emulator_TT.in_MinMax.shape}\")\nprint(f\"- Output normalization shape: {emulator_TT.out_MinMax.shape}\")\nprint(f\"- Has postprocessing: {callable(emulator_TT.postprocessing)}\")\n</code></pre>"},{"location":"getting_started/tutorial/#understanding-parameter-space","title":"Understanding Parameter Space","text":"<pre><code># Get parameter information\ndesc = emulator_TT.emulator_description\nprint(f\"Parameters: {desc['parameters']}\")\n\n# Check training bounds\nbounds = emulator_TT.in_MinMax\nparam_names = ['ln10As', 'ns', 'H0', '\u03c9b', '\u03c9c', '\u03c4']\n\nfor i, name in enumerate(param_names):\n    print(f\"{name}: [{bounds[i,0]:.3f}, {bounds[i,1]:.3f}]\")\n</code></pre>"},{"location":"getting_started/tutorial/#computing-your-first-spectrum","title":"Computing Your First Spectrum","text":"<pre><code># Define a fiducial cosmology\nfiducial_params = jnp.array([\n    3.05,   # ln10As\n    0.965,  # ns\n    67.36,  # H0\n    0.0224, # \u03c9b\n    0.120,  # \u03c9c\n    0.054   # \u03c4\n])\n\n# Compute the TT spectrum\ncl_TT = emulator_TT.get_Cl(fiducial_params)\n\n# Plot the result\nell = jnp.arange(2, len(cl_TT) + 2)\nplt.figure(figsize=(8, 5))\nplt.plot(ell, cl_TT)\nplt.xlabel(r'$\\ell$')\nplt.ylabel(r'$C_\\ell^{TT}$ [$\\mu K^2$]')\nplt.title('CMB Temperature Power Spectrum')\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"getting_started/tutorial/#part-2-parameter-variations","title":"Part 2: Parameter Variations","text":""},{"location":"getting_started/tutorial/#exploring-parameter-dependencies","title":"Exploring Parameter Dependencies","text":"<pre><code># Create parameter variations\ndef vary_parameter(base_params, param_idx, values):\n    \"\"\"Vary one parameter while keeping others fixed.\"\"\"\n    results = []\n    for val in values:\n        params = base_params.copy()\n        params = params.at[param_idx].set(val)\n        results.append(emulator_TT.get_Cl(params))\n    return jnp.array(results)\n\n# Vary spectral index\nns_values = jnp.linspace(0.92, 1.00, 5)\ncl_ns_varied = vary_parameter(fiducial_params, 1, ns_values)\n\n# Plot variations\nplt.figure(figsize=(10, 6))\nfor i, ns in enumerate(ns_values):\n    plt.plot(ell, cl_ns_varied[i], label=f'ns = {ns:.3f}')\nplt.xlabel(r'$\\ell$')\nplt.ylabel(r'$C_\\ell^{TT}$ [$\\mu K^2$]')\nplt.legend()\nplt.title('Effect of Spectral Index on TT Spectrum')\nplt.show()\n</code></pre>"},{"location":"getting_started/tutorial/#computing-ratios","title":"Computing Ratios","text":"<pre><code># Compute ratios relative to fiducial\nplt.figure(figsize=(10, 6))\nfor i, ns in enumerate(ns_values):\n    ratio = cl_ns_varied[i] / cl_TT\n    plt.plot(ell, ratio, label=f'ns = {ns:.3f}')\n\nplt.xlabel(r'$\\ell$')\nplt.ylabel(r'$C_\\ell / C_\\ell^{\\rm fid}$')\nplt.axhline(1, color='black', linestyle='--', alpha=0.5)\nplt.legend()\nplt.title('Relative Change in TT Spectrum')\nplt.show()\n</code></pre>"},{"location":"getting_started/tutorial/#part-3-gradients-and-derivatives","title":"Part 3: Gradients and Derivatives","text":""},{"location":"getting_started/tutorial/#computing-jacobians","title":"Computing Jacobians","text":"<pre><code># Compute Jacobian matrix (derivatives w.r.t. all parameters)\njacobian_fn = jax.jacfwd(emulator_TT.get_Cl)\njacobian = jacobian_fn(fiducial_params)\n\nprint(f\"Jacobian shape: {jacobian.shape}\")  # (n_ell, n_params)\n\n# Plot derivatives for selected \u2113 values\nfig, axes = plt.subplots(2, 3, figsize=(12, 8))\nell_samples = [10, 100, 500, 1000, 2000, 3000]\n\nfor ax, ell_idx in zip(axes.flat, ell_samples):\n    derivatives = jacobian[ell_idx - 2, :]  # Adjust for \u2113 starting at 2\n    ax.bar(param_names, derivatives)\n    ax.set_title(f'$\\\\partial C_{{\\\\ell={ell_idx}}}^{{TT}} / \\\\partial \\\\theta$')\n    ax.tick_params(axis='x', rotation=45)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"getting_started/tutorial/#fisher-matrix-computation","title":"Fisher Matrix Computation","text":"<pre><code>def compute_fisher_matrix(emulator, params, ell_max=3000):\n    \"\"\"Compute Fisher information matrix.\"\"\"\n    # Get Jacobian\n    jacobian = jax.jacfwd(emulator.get_Cl)(params)[:ell_max-1]\n\n    # Assume cosmic variance limited\n    cl = emulator.get_Cl(params)[:ell_max-1]\n    ell = jnp.arange(2, ell_max+1)\n\n    # Covariance (simplified - cosmic variance only)\n    variance = 2 * cl**2 / (2*ell + 1)\n\n    # Fisher matrix\n    fisher = jnp.zeros((6, 6))\n    for l in range(len(ell)):\n        fisher += jnp.outer(jacobian[l], jacobian[l]) / variance[l]\n\n    return fisher\n\n# Compute Fisher matrix\nfisher = compute_fisher_matrix(emulator_TT, fiducial_params)\n\n# Plot correlation matrix\ncorrelation = jnp.zeros_like(fisher)\nfor i in range(6):\n    for j in range(6):\n        correlation = correlation.at[i,j].set(\n            fisher[i,j] / jnp.sqrt(fisher[i,i] * fisher[j,j])\n        )\n\nplt.figure(figsize=(8, 6))\nplt.imshow(correlation, cmap='RdBu_r', vmin=-1, vmax=1)\nplt.colorbar(label='Correlation')\nplt.xticks(range(6), param_names, rotation=45)\nplt.yticks(range(6), param_names)\nplt.title('Parameter Correlation Matrix')\nplt.show()\n</code></pre>"},{"location":"getting_started/tutorial/#part-4-batch-processing","title":"Part 4: Batch Processing","text":""},{"location":"getting_started/tutorial/#processing-multiple-cosmologies","title":"Processing Multiple Cosmologies","text":"<pre><code># Generate a batch of cosmologies\nn_samples = 100\nkey = jax.random.PRNGKey(42)\n\n# Random variations around fiducial\nvariations = jax.random.normal(key, (n_samples, 6)) * 0.01\nbatch_params = fiducial_params + variations\n\n# Ensure within bounds\nbatch_params = jnp.clip(batch_params, \n                        emulator_TT.in_MinMax[:, 0],\n                        emulator_TT.in_MinMax[:, 1])\n\n# Compute all spectra\ncl_batch = emulator_TT.get_Cl_batch(batch_params)\nprint(f\"Batch output shape: {cl_batch.shape}\")\n\n# Plot statistics\nmean_cl = jnp.mean(cl_batch, axis=0)\nstd_cl = jnp.std(cl_batch, axis=0)\n\nplt.figure(figsize=(10, 6))\nplt.plot(ell, mean_cl, 'b-', label='Mean')\nplt.fill_between(ell, mean_cl - std_cl, mean_cl + std_cl, \n                 alpha=0.3, label='\u00b11\u03c3')\nplt.xlabel(r'$\\ell$')\nplt.ylabel(r'$C_\\ell^{TT}$ [$\\mu K^2$]')\nplt.legend()\nplt.title(f'Statistics from {n_samples} Cosmologies')\nplt.show()\n</code></pre>"},{"location":"getting_started/tutorial/#performance-comparison","title":"Performance Comparison","text":"<pre><code>import time\n\n# Time batch processing\nstart = time.perf_counter()\ncl_batch = emulator_TT.get_Cl_batch(batch_params)\nbatch_time = time.perf_counter() - start\n\n# Time individual processing\nstart = time.perf_counter()\ncl_individual = jnp.array([emulator_TT.get_Cl(p) for p in batch_params])\nindividual_time = time.perf_counter() - start\n\nprint(f\"Batch processing: {batch_time*1000:.1f} ms\")\nprint(f\"Individual processing: {individual_time*1000:.1f} ms\")\nprint(f\"Speedup: {individual_time/batch_time:.1f}x\")\n</code></pre>"},{"location":"getting_started/tutorial/#part-5-all-spectra-together","title":"Part 5: All Spectra Together","text":""},{"location":"getting_started/tutorial/#loading-all-emulators","title":"Loading All Emulators","text":"<pre><code># Load all available emulators\nemulator_names = ['TT', 'EE', 'TE', 'PP']\nemulators = {}\n\nfor name in emulator_names:\n    path = f\"trained_emu/{name}/\"\n    try:\n        emulators[name] = jaxcapse.load_emulator(path)\n        print(f\"\u2713 Loaded {name} emulator\")\n    except:\n        print(f\"\u2717 Could not load {name} emulator\")\n</code></pre>"},{"location":"getting_started/tutorial/#computing-cross-correlations","title":"Computing Cross-Correlations","text":"<pre><code># Compute all spectra\nall_spectra = {name: em.get_Cl(fiducial_params) \n               for name, em in emulators.items()}\n\n# Create comprehensive plot\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\nplot_config = {\n    'TT': {'ax': axes[0,0], 'ylabel': r'$\\ell(\\ell+1)C_\\ell^{TT}/2\\pi$ [$\\mu K^2$]'},\n    'EE': {'ax': axes[0,1], 'ylabel': r'$\\ell(\\ell+1)C_\\ell^{EE}/2\\pi$ [$\\mu K^2$]'},\n    'TE': {'ax': axes[1,0], 'ylabel': r'$\\ell(\\ell+1)C_\\ell^{TE}/2\\pi$ [$\\mu K^2$]'},\n    'PP': {'ax': axes[1,1], 'ylabel': r'$\\ell^2(\\ell+1)^2C_\\ell^{\\phi\\phi}/2\\pi$'}\n}\n\nfor name, cl in all_spectra.items():\n    if name in plot_config:\n        ax = plot_config[name]['ax']\n        ell = jnp.arange(2, len(cl) + 2)\n\n        # Apply appropriate \u2113 scaling\n        if name == 'PP':\n            scaling = ell**2 * (ell + 1)**2 / (2*jnp.pi)\n            ax.semilogy(ell, cl * scaling)\n        else:\n            scaling = ell * (ell + 1) / (2*jnp.pi)\n            ax.plot(ell, cl * scaling)\n\n        ax.set_xlabel(r'$\\ell$')\n        ax.set_ylabel(plot_config[name]['ylabel'])\n        ax.set_title(f'{name} Spectrum')\n        ax.grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"getting_started/tutorial/#part-6-advanced-jax-features","title":"Part 6: Advanced JAX Features","text":""},{"location":"getting_started/tutorial/#using-vmap-for-parameter-studies","title":"Using vmap for Parameter Studies","text":"<pre><code># Define a parameter grid\nAs_range = jnp.linspace(2.8, 3.3, 10)\nns_range = jnp.linspace(0.92, 1.00, 10)\n\n# Create 2D grid\nAs_grid, ns_grid = jnp.meshgrid(As_range, ns_range)\n\n# Prepare parameters (flatten grid)\ngrid_params = []\nfor i in range(10):\n    for j in range(10):\n        params = fiducial_params.copy()\n        params = params.at[0].set(As_grid[i, j])\n        params = params.at[1].set(ns_grid[i, j])\n        grid_params.append(params)\n\ngrid_params = jnp.array(grid_params)\n\n# Use vmap for efficient computation\nvmap_get_cl = jax.vmap(emulator_TT.get_Cl)\ncl_grid = vmap_get_cl(grid_params)\n\n# Extract amplitude at specific \u2113\nell_target = 1000\namplitude_grid = cl_grid[:, ell_target-2].reshape(10, 10)\n\n# Plot parameter dependence\nplt.figure(figsize=(10, 8))\nplt.contourf(As_range, ns_range, amplitude_grid, levels=20, cmap='viridis')\nplt.colorbar(label=f'$C_{{{ell_target}}}^{{TT}}$ [$\\\\mu K^2$]')\nplt.xlabel('ln10As')\nplt.ylabel('ns')\nplt.title(f'TT Spectrum Amplitude at $\\\\ell = {ell_target}$')\nplt.show()\n</code></pre>"},{"location":"getting_started/tutorial/#optimization-example","title":"Optimization Example","text":"<pre><code>from scipy.optimize import minimize\n\n# Define a mock \"observed\" spectrum\ntrue_params = jnp.array([3.08, 0.968, 68.0, 0.0223, 0.118, 0.056])\nobserved_cl = emulator_TT.get_Cl(true_params)\n\n# Add noise\nkey = jax.random.PRNGKey(123)\nnoise = jax.random.normal(key, observed_cl.shape) * 10\nobserved_cl_noisy = observed_cl + noise\n\n# Define chi-squared function\ndef chi2(params):\n    params_jax = jnp.array(params)\n    theory_cl = emulator_TT.get_Cl(params_jax)\n    return float(jnp.sum((theory_cl - observed_cl_noisy)**2 / (2 * observed_cl)))\n\n# Optimize\nresult = minimize(chi2, fiducial_params, method='L-BFGS-B',\n                 bounds=[(b[0], b[1]) for b in emulator_TT.in_MinMax])\n\nprint(\"True parameters:     \", true_params)\nprint(\"Recovered parameters:\", result.x)\nprint(\"Chi-squared:        \", result.fun)\n</code></pre>"},{"location":"getting_started/tutorial/#summary","title":"Summary","text":"<p>You've learned how to:</p> <ol> <li>Load and use JaxCapse emulators</li> <li>Compute CMB power spectra for different cosmologies</li> <li>Calculate gradients and Fisher matrices</li> <li>Process batches of parameters efficiently</li> <li>Use advanced JAX features like vmap</li> <li>Perform parameter optimization</li> </ol>"},{"location":"getting_started/tutorial/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Reference for detailed documentation</li> <li>See Examples for more use cases</li> <li>Learn about JAX Features in depth</li> </ul>"},{"location":"user_guide/batch/","title":"Batch Processing","text":"<p>Efficiently process multiple cosmologies simultaneously with JaxCapse.</p>"},{"location":"user_guide/batch/#basic-batch-processing","title":"Basic Batch Processing","text":"<pre><code>import jaxcapse\nimport jax.numpy as jnp\n\n# Load emulator\nemulator = jaxcapse.load_emulator(\"trained_emu/TT/\")\n\n# Create batch of parameters\nbatch_params = jnp.array([\n    [3.1, 0.96, 67.0, 0.022, 0.12, 0.055],\n    [3.0, 0.97, 68.0, 0.023, 0.11, 0.060],\n    [3.2, 0.95, 66.0, 0.021, 0.13, 0.050]\n])\n\n# Process batch\ncl_batch = emulator.get_Cl_batch(batch_params)\nprint(f\"Output shape: {cl_batch.shape}\")  # (3, n_ell)\n</code></pre>"},{"location":"user_guide/batch/#performance-benefits","title":"Performance Benefits","text":"<pre><code>import time\n\n# Create large batch\nn_cosmologies = 1000\nbatch = jnp.tile([3.1, 0.96, 67.0, 0.022, 0.12, 0.055], (n_cosmologies, 1))\n\n# Time batch processing\nstart = time.perf_counter()\ncl_batch = emulator.get_Cl_batch(batch)\nbatch_time = time.perf_counter() - start\n\n# Time individual processing\nstart = time.perf_counter()\ncl_individual = jnp.array([emulator.get_Cl(p) for p in batch])\nindividual_time = time.perf_counter() - start\n\nprint(f\"Batch: {batch_time:.3f}s\")\nprint(f\"Individual: {individual_time:.3f}s\")\nprint(f\"Speedup: {individual_time/batch_time:.1f}x\")\n</code></pre>"},{"location":"user_guide/batch/#memory-management","title":"Memory Management","text":"<pre><code>def process_large_dataset(params, emulator, chunk_size=1000):\n    \"\"\"Process large dataset in chunks.\"\"\"\n    n_total = len(params)\n    results = []\n\n    for i in range(0, n_total, chunk_size):\n        chunk = params[i:i+chunk_size]\n        cl_chunk = emulator.get_Cl_batch(chunk)\n        results.append(cl_chunk)\n\n    return jnp.concatenate(results, axis=0)\n</code></pre>"},{"location":"user_guide/batch/#next-steps","title":"Next Steps","text":"<ul> <li>JAX Features: Advanced JAX functionality</li> </ul>"},{"location":"user_guide/computing/","title":"Computing Power Spectra","text":"<p>This guide covers computing CMB power spectra with JaxCapse.</p>"},{"location":"user_guide/computing/#basic-computation","title":"Basic Computation","text":""},{"location":"user_guide/computing/#single-evaluation","title":"Single Evaluation","text":"<pre><code>import jaxcapse\nimport jax.numpy as jnp\n\n# Load emulator\nemulator = jaxcapse.load_emulator(\"trained_emu/TT/\")\n\n# Define parameters [ln10As, ns, H0, \u03c9b, \u03c9c, \u03c4]\nparams = jnp.array([3.1, 0.96, 67.0, 0.022, 0.12, 0.055])\n\n# Compute spectrum\ncl = emulator.get_Cl(params)\n</code></pre>"},{"location":"user_guide/computing/#multiple-spectra","title":"Multiple Spectra","text":"<pre><code># Load all emulators\nemulators = {\n    'TT': jaxcapse.load_emulator(\"trained_emu/TT/\"),\n    'EE': jaxcapse.load_emulator(\"trained_emu/EE/\"),\n    'TE': jaxcapse.load_emulator(\"trained_emu/TE/\"),\n    'PP': jaxcapse.load_emulator(\"trained_emu/PP/\")\n}\n\n# Compute all spectra\nspectra = {name: em.get_Cl(params) \n           for name, em in emulators.items()}\n</code></pre>"},{"location":"user_guide/computing/#parameter-input","title":"Parameter Input","text":""},{"location":"user_guide/computing/#parameter-order","title":"Parameter Order","text":"<p>Parameters must be provided in this exact order:</p> <ol> <li>ln10As: Natural log of 10^10 * As</li> <li>ns: Scalar spectral index</li> <li>H0: Hubble constant [km/s/Mpc]</li> <li>\u03c9b: Physical baryon density (\u03a9b * h\u00b2)</li> <li>\u03c9c: Physical CDM density (\u03a9c * h\u00b2)</li> <li>\u03c4: Optical depth to reionization</li> </ol>"},{"location":"user_guide/computing/#parameter-validation","title":"Parameter Validation","text":"<pre><code>def validate_parameters(params, emulator):\n    \"\"\"Validate parameters are within bounds.\"\"\"\n    bounds = emulator.in_MinMax\n\n    for i, (val, (min_val, max_val)) in enumerate(zip(params, bounds)):\n        if not (min_val &lt;= val &lt;= max_val):\n            param_names = ['ln10As', 'ns', 'H0', '\u03c9b', '\u03c9c', '\u03c4']\n            raise ValueError(\n                f\"Parameter {param_names[i]} = {val} \"\n                f\"outside bounds [{min_val}, {max_val}]\"\n            )\n\n    return True\n\n# Validate before computing\nvalidate_parameters(params, emulator)\ncl = emulator.get_Cl(params)\n</code></pre>"},{"location":"user_guide/computing/#output-format","title":"Output Format","text":""},{"location":"user_guide/computing/#understanding-output","title":"Understanding Output","text":"<pre><code># Compute spectrum\ncl = emulator.get_Cl(params)\n\n# Output properties\nprint(f\"Shape: {cl.shape}\")           # Number of \u2113 values\nprint(f\"Data type: {cl.dtype}\")       # float64 by default\nprint(f\"Min value: {cl.min():.2e}\")   # Minimum Cl\nprint(f\"Max value: {cl.max():.2e}\")   # Maximum Cl\n\n# Get \u2113 values\nell = jnp.arange(2, len(cl) + 2)      # \u2113 starts at 2\n</code></pre>"},{"location":"user_guide/computing/#physical-units","title":"Physical Units","text":"<p>Different spectra have different units:</p> Spectrum Units Description TT \u03bcK\u00b2 Temperature fluctuations squared EE \u03bcK\u00b2 E-mode polarization squared TE \u03bcK\u00b2 Temperature-polarization cross PP dimensionless Lensing potential"},{"location":"user_guide/computing/#applying-l-factors","title":"Applying \u2113 Factors","text":"<pre><code># Standard CMB plotting convention\nell = jnp.arange(2, len(cl) + 2)\n\n# D_\u2113 = \u2113(\u2113+1)C_\u2113/2\u03c0\ndl = ell * (ell + 1) * cl / (2 * jnp.pi)\n\n# For lensing potential\nif spectrum_type == 'PP':\n    # [\u2113(\u2113+1)]\u00b2C_\u2113^\u03c6\u03c6/2\u03c0\n    dl = (ell * (ell + 1))**2 * cl / (2 * jnp.pi)\n</code></pre>"},{"location":"user_guide/computing/#performance-optimization","title":"Performance Optimization","text":""},{"location":"user_guide/computing/#jit-compilation","title":"JIT Compilation","text":"<pre><code># First call includes compilation\nstart = time.time()\ncl1 = emulator.get_Cl(params)\nprint(f\"First call: {(time.time() - start)*1000:.1f} ms\")\n\n# Subsequent calls are faster\nstart = time.time()\ncl2 = emulator.get_Cl(params)\nprint(f\"Second call: {(time.time() - start)*1000:.1f} ms\")\n</code></pre>"},{"location":"user_guide/computing/#avoiding-recompilation","title":"Avoiding Recompilation","text":"<pre><code># Recompilation happens with different shapes\nparams_6d = jnp.array([3.1, 0.96, 67.0, 0.022, 0.12, 0.055])\nparams_5d = jnp.array([3.1, 0.96, 67.0, 0.022, 0.12])  # Wrong!\n\n# This causes recompilation (and error)\n# cl = emulator.get_Cl(params_5d)  # Don't do this\n</code></pre>"},{"location":"user_guide/computing/#advanced-computation","title":"Advanced Computation","text":""},{"location":"user_guide/computing/#custom-postprocessing","title":"Custom Postprocessing","text":"<pre><code>def compute_with_custom_processing(emulator, params, custom_fn):\n    \"\"\"Apply custom postprocessing to spectrum.\"\"\"\n    # Get raw spectrum\n    cl = emulator.get_Cl(params)\n\n    # Apply custom processing\n    processed = custom_fn(cl)\n\n    return processed\n\n# Example: Apply smoothing\ndef smooth_spectrum(cl, window=10):\n    \"\"\"Apply running mean smoothing.\"\"\"\n    from scipy.ndimage import uniform_filter1d\n    return uniform_filter1d(cl, window, mode='nearest')\n\ncl_smooth = compute_with_custom_processing(\n    emulator, params, lambda cl: smooth_spectrum(cl, 20)\n)\n</code></pre>"},{"location":"user_guide/computing/#combining-spectra","title":"Combining Spectra","text":"<pre><code>def compute_chi_squared(params, observed_data):\n    \"\"\"Compute \u03c7\u00b2 for parameter set.\"\"\"\n    # Compute theory\n    cl_theory = emulator.get_Cl(params)\n\n    # Compute \u03c7\u00b2\n    residuals = cl_theory - observed_data['cl']\n    chi2 = jnp.sum(residuals**2 / observed_data['variance'])\n\n    return chi2\n\n# Use in optimization\nfrom scipy.optimize import minimize\n\nresult = minimize(\n    lambda p: compute_chi_squared(jnp.array(p), data),\n    initial_params,\n    bounds=emulator.in_MinMax\n)\n</code></pre>"},{"location":"user_guide/computing/#spectrum-ratios","title":"Spectrum Ratios","text":"<pre><code>def compute_ratio_spectrum(params1, params2, emulator):\n    \"\"\"Compute ratio of two spectra.\"\"\"\n    cl1 = emulator.get_Cl(params1)\n    cl2 = emulator.get_Cl(params2)\n\n    # Avoid division by zero\n    ratio = jnp.where(cl2 &gt; 0, cl1 / cl2, 1.0)\n\n    return ratio\n\n# Compare cosmologies\nfiducial = jnp.array([3.05, 0.965, 67.36, 0.0224, 0.120, 0.054])\nmodified = jnp.array([3.10, 0.965, 67.36, 0.0224, 0.120, 0.054])\n\nratio = compute_ratio_spectrum(modified, fiducial, emulator)\n</code></pre>"},{"location":"user_guide/computing/#error-handling","title":"Error Handling","text":""},{"location":"user_guide/computing/#common-issues","title":"Common Issues","text":"<pre><code>def safe_compute(emulator, params):\n    \"\"\"Compute spectrum with error handling.\"\"\"\n    try:\n        # Validate input\n        if not isinstance(params, jnp.ndarray):\n            params = jnp.array(params)\n\n        if params.shape != (6,):\n            raise ValueError(f\"Expected 6 parameters, got {len(params)}\")\n\n        # Check for NaN/Inf\n        if not jnp.all(jnp.isfinite(params)):\n            raise ValueError(\"Parameters contain NaN or Inf\")\n\n        # Compute\n        cl = emulator.get_Cl(params)\n\n        # Validate output\n        if not jnp.all(jnp.isfinite(cl)):\n            raise RuntimeError(\"Output contains NaN or Inf\")\n\n        return cl\n\n    except Exception as e:\n        print(f\"Computation failed: {e}\")\n        return None\n</code></pre>"},{"location":"user_guide/computing/#next-steps","title":"Next Steps","text":"<ul> <li>Batch Processing: Process multiple cosmologies</li> <li>JAX Features: Gradients and transformations</li> <li>Examples: Complete examples</li> </ul>"},{"location":"user_guide/jax_features/","title":"JAX Features","text":"<p>Leverage JAX's powerful transformations with JaxCapse.</p>"},{"location":"user_guide/jax_features/#automatic-differentiation","title":"Automatic Differentiation","text":""},{"location":"user_guide/jax_features/#gradients","title":"Gradients","text":"<pre><code>import jax\nimport jax.numpy as jnp\n\n# Define loss function\ndef loss(params, emulator):\n    cl = emulator.get_Cl(params)\n    return jnp.sum(cl**2)\n\n# Compute gradient\ngrad_fn = jax.grad(loss, argnums=0)\nparams = jnp.array([3.1, 0.96, 67.0, 0.022, 0.12, 0.055])\ngradients = grad_fn(params, emulator)\n</code></pre>"},{"location":"user_guide/jax_features/#jacobian","title":"Jacobian","text":"<pre><code># Forward-mode (efficient for many outputs)\njacobian = jax.jacfwd(emulator.get_Cl)(params)\nprint(f\"Jacobian shape: {jacobian.shape}\")  # (n_ell, n_params)\n\n# Reverse-mode (efficient for many inputs)\njacobian_rev = jax.jacrev(emulator.get_Cl)(params)\n</code></pre>"},{"location":"user_guide/jax_features/#vectorization","title":"Vectorization","text":"<pre><code># Vectorize single-input function\nvmap_get_cl = jax.vmap(emulator.get_Cl)\n\n# Process batch\nbatch = jnp.array([[3.1, 0.96, 67.0, 0.022, 0.12, 0.055],\n                   [3.0, 0.97, 68.0, 0.023, 0.11, 0.060]])\ncl_batch = vmap_get_cl(batch)\n</code></pre>"},{"location":"user_guide/jax_features/#jit-compilation","title":"JIT Compilation","text":"<pre><code># JIT compile for speed\n@jax.jit\ndef fast_compute(params):\n    return emulator.get_Cl(params)\n\n# First call compiles\ncl = fast_compute(params)  # ~1ms\n\n# Subsequent calls are fast\ncl = fast_compute(params)  # ~50\u03bcs\n</code></pre>"},{"location":"user_guide/loading/","title":"Loading Emulators","text":"<p>This guide covers how to load and configure JaxCapse emulators.</p>"},{"location":"user_guide/loading/#basic-loading","title":"Basic Loading","text":""},{"location":"user_guide/loading/#single-emulator","title":"Single Emulator","text":"<pre><code>import jaxcapse\n\n# Load a single emulator\nemulator_TT = jaxcapse.load_emulator(\"trained_emu/TT/\")\n</code></pre>"},{"location":"user_guide/loading/#multiple-emulators","title":"Multiple Emulators","text":"<pre><code># Load all available emulators\nemulators = {}\nfor spectrum in ['TT', 'EE', 'TE', 'PP']:\n    path = f\"trained_emu/{spectrum}/\"\n    emulators[spectrum] = jaxcapse.load_emulator(path)\n</code></pre>"},{"location":"user_guide/loading/#directory-structure","title":"Directory Structure","text":"<p>Each emulator directory must contain:</p> <pre><code>trained_emu/TT/\n\u251c\u2500\u2500 nn_setup.json       # Network architecture\n\u251c\u2500\u2500 weights.npy         # Trained weights\n\u251c\u2500\u2500 inminmax.npy       # Input normalization\n\u251c\u2500\u2500 outminmax.npy      # Output normalization\n\u2514\u2500\u2500 postprocessing.py  # Postprocessing function\n</code></pre>"},{"location":"user_guide/loading/#inspecting-emulator-properties","title":"Inspecting Emulator Properties","text":""},{"location":"user_guide/loading/#emulator-description","title":"Emulator Description","text":"<pre><code># View metadata\ndesc = emulator_TT.emulator_description\nprint(f\"Author: {desc['author']}\")\nprint(f\"Parameters: {desc['parameters']}\")\nprint(f\"Info: {desc['miscellanea']}\")\n</code></pre>"},{"location":"user_guide/loading/#parameter-bounds","title":"Parameter Bounds","text":"<pre><code># Check training ranges\nbounds = emulator_TT.in_MinMax\nparam_names = ['ln10As', 'ns', 'H0', '\u03c9b', '\u03c9c', '\u03c4']\n\nfor i, name in enumerate(param_names):\n    min_val, max_val = bounds[i]\n    print(f\"{name}: [{min_val:.3f}, {max_val:.3f}]\")\n</code></pre>"},{"location":"user_guide/loading/#output-information","title":"Output Information","text":"<pre><code># Check output normalization\nout_bounds = emulator_TT.out_MinMax\nprint(f\"Number of \u2113 values: {len(out_bounds)}\")\nprint(f\"Output range: [{out_bounds.min():.2e}, {out_bounds.max():.2e}]\")\n</code></pre>"},{"location":"user_guide/loading/#error-handling","title":"Error Handling","text":""},{"location":"user_guide/loading/#missing-files","title":"Missing Files","text":"<pre><code>try:\n    emulator = jaxcapse.load_emulator(\"path/to/emulator/\")\nexcept FileNotFoundError as e:\n    print(f\"Missing file: {e}\")\n    # Handle missing emulator files\n</code></pre>"},{"location":"user_guide/loading/#invalid-configuration","title":"Invalid Configuration","text":"<pre><code>try:\n    emulator = jaxcapse.load_emulator(\"corrupted/emulator/\")\nexcept json.JSONDecodeError:\n    print(\"Invalid nn_setup.json file\")\nexcept ValueError as e:\n    print(f\"Configuration error: {e}\")\n</code></pre>"},{"location":"user_guide/loading/#custom-emulator-paths","title":"Custom Emulator Paths","text":""},{"location":"user_guide/loading/#from-environment-variable","title":"From Environment Variable","text":"<pre><code>import os\n\n# Set custom path\nemulator_dir = os.environ.get('JAXCAPSE_DATA', 'trained_emu')\nemulator = jaxcapse.load_emulator(f\"{emulator_dir}/TT/\")\n</code></pre>"},{"location":"user_guide/loading/#from-configuration-file","title":"From Configuration File","text":"<pre><code>import json\n\n# Load paths from config\nwith open('config.json', 'r') as f:\n    config = json.load(f)\n\nemulator = jaxcapse.load_emulator(config['emulator_path'])\n</code></pre>"},{"location":"user_guide/loading/#validating-emulators","title":"Validating Emulators","text":""},{"location":"user_guide/loading/#quick-validation","title":"Quick Validation","text":"<pre><code>def validate_emulator(emulator):\n    \"\"\"Quick validation of loaded emulator.\"\"\"\n    import jax.numpy as jnp\n\n    # Test with fiducial parameters\n    test_params = jnp.array([3.05, 0.965, 67.36, 0.0224, 0.120, 0.054])\n\n    try:\n        # Compute spectrum\n        cl = emulator.get_Cl(test_params)\n\n        # Check output\n        assert cl.shape[0] &gt; 0, \"Empty output\"\n        assert jnp.all(jnp.isfinite(cl)), \"Non-finite values\"\n        assert jnp.all(cl &gt;= 0), \"Negative power spectrum\"\n\n        print(\"\u2713 Emulator validation passed\")\n        return True\n    except Exception as e:\n        print(f\"\u2717 Validation failed: {e}\")\n        return False\n\n# Validate\nvalidate_emulator(emulator_TT)\n</code></pre>"},{"location":"user_guide/loading/#comprehensive-testing","title":"Comprehensive Testing","text":"<pre><code>def test_emulator_comprehensive(emulator):\n    \"\"\"Comprehensive emulator testing.\"\"\"\n    import jax\n    import jax.numpy as jnp\n\n    # Test parameters\n    params = jnp.array([3.05, 0.965, 67.36, 0.0224, 0.120, 0.054])\n\n    tests_passed = []\n\n    # Test 1: Basic computation\n    try:\n        cl = emulator.get_Cl(params)\n        tests_passed.append(\"Basic computation\")\n    except:\n        pass\n\n    # Test 2: Batch processing\n    try:\n        batch = jnp.tile(params, (10, 1))\n        cl_batch = emulator.get_Cl_batch(batch)\n        tests_passed.append(\"Batch processing\")\n    except:\n        pass\n\n    # Test 3: Gradients\n    try:\n        grad = jax.grad(lambda p: jnp.sum(emulator.get_Cl(p)))(params)\n        tests_passed.append(\"Gradient computation\")\n    except:\n        pass\n\n    # Test 4: JIT compilation\n    try:\n        jit_fn = jax.jit(emulator.get_Cl)\n        cl_jit = jit_fn(params)\n        tests_passed.append(\"JIT compilation\")\n    except:\n        pass\n\n    print(f\"Passed {len(tests_passed)}/4 tests:\")\n    for test in tests_passed:\n        print(f\"  \u2713 {test}\")\n\n    return len(tests_passed) == 4\n</code></pre>"},{"location":"user_guide/loading/#memory-management","title":"Memory Management","text":""},{"location":"user_guide/loading/#loading-multiple-emulators","title":"Loading Multiple Emulators","text":"<pre><code>import gc\n\n# Load emulators efficiently\ndef load_all_emulators(base_path=\"trained_emu\"):\n    \"\"\"Load all emulators with memory management.\"\"\"\n    emulators = {}\n\n    for spectrum in ['TT', 'EE', 'TE', 'PP']:\n        try:\n            path = f\"{base_path}/{spectrum}/\"\n            emulators[spectrum] = jaxcapse.load_emulator(path)\n            print(f\"Loaded {spectrum}\")\n        except Exception as e:\n            print(f\"Failed to load {spectrum}: {e}\")\n\n    # Force garbage collection\n    gc.collect()\n\n    return emulators\n</code></pre>"},{"location":"user_guide/loading/#unloading-emulators","title":"Unloading Emulators","text":"<pre><code># Clear emulator from memory\ndel emulator_TT\ngc.collect()\n</code></pre>"},{"location":"user_guide/loading/#advanced-loading-options","title":"Advanced Loading Options","text":""},{"location":"user_guide/loading/#lazy-loading","title":"Lazy Loading","text":"<pre><code>class LazyEmulatorLoader:\n    \"\"\"Load emulators on demand.\"\"\"\n\n    def __init__(self, base_path=\"trained_emu\"):\n        self.base_path = base_path\n        self._emulators = {}\n\n    def get(self, spectrum):\n        \"\"\"Get emulator, loading if necessary.\"\"\"\n        if spectrum not in self._emulators:\n            path = f\"{self.base_path}/{spectrum}/\"\n            self._emulators[spectrum] = jaxcapse.load_emulator(path)\n        return self._emulators[spectrum]\n\n    def unload(self, spectrum):\n        \"\"\"Unload specific emulator.\"\"\"\n        if spectrum in self._emulators:\n            del self._emulators[spectrum]\n\n# Usage\nloader = LazyEmulatorLoader()\nemulator_TT = loader.get('TT')  # Loads on first access\nemulator_TT = loader.get('TT')  # Returns cached version\n</code></pre>"},{"location":"user_guide/loading/#parallel-loading","title":"Parallel Loading","text":"<pre><code>from concurrent.futures import ThreadPoolExecutor\n\ndef load_emulator_wrapper(args):\n    \"\"\"Wrapper for parallel loading.\"\"\"\n    spectrum, base_path = args\n    try:\n        path = f\"{base_path}/{spectrum}/\"\n        return spectrum, jaxcapse.load_emulator(path)\n    except:\n        return spectrum, None\n\n# Load in parallel\nspectra = ['TT', 'EE', 'TE', 'PP']\nbase_path = \"trained_emu\"\n\nwith ThreadPoolExecutor(max_workers=4) as executor:\n    args = [(s, base_path) for s in spectra]\n    results = executor.map(load_emulator_wrapper, args)\n    emulators = dict(results)\n\n# Filter out failed loads\nemulators = {k: v for k, v in emulators.items() if v is not None}\n</code></pre>"},{"location":"user_guide/loading/#next-steps","title":"Next Steps","text":"<ul> <li>Computing Spectra: Use loaded emulators</li> <li>Batch Processing: Process multiple cosmologies</li> <li>JAX Features: Advanced functionality</li> </ul>"},{"location":"user_guide/overview/","title":"User Guide Overview","text":"<p>This guide provides detailed information on using JaxCapse for CMB power spectrum emulation.</p>"},{"location":"user_guide/overview/#what-is-jaxcapse","title":"What is JaxCapse?","text":"<p>JaxCapse is a JAX-based neural network emulator for computing CMB power spectra. It provides:</p> <ul> <li>Speed: ~1000x faster than Boltzmann solvers</li> <li>Accuracy: Sub-percent precision across parameter space</li> <li>Differentiability: Automatic gradients for parameter estimation</li> <li>Efficiency: Batch processing and GPU acceleration</li> </ul>"},{"location":"user_guide/overview/#architecture","title":"Architecture","text":"<p>JaxCapse consists of:</p> <ol> <li>Neural Network Core: Multi-layer perceptron trained on Boltzmann solver outputs</li> <li>JAX Integration: Full compatibility with JAX transformations</li> <li>Normalization Layer: Input/output scaling for numerical stability</li> <li>Postprocessing: Spectrum-specific transformations</li> </ol>"},{"location":"user_guide/overview/#workflow","title":"Workflow","text":"<pre><code>graph LR\n    A[Cosmological Parameters] --&gt; B[Input Normalization]\n    B --&gt; C[Neural Network]\n    C --&gt; D[Output Denormalization]\n    D --&gt; E[Postprocessing]\n    E --&gt; F[Power Spectrum Cl]\n</code></pre>"},{"location":"user_guide/overview/#supported-parameters","title":"Supported Parameters","text":"<p>JaxCapse emulators take 6 cosmological parameters:</p> Parameter Symbol Description Typical Range ln10As ln(10\u00b9\u2070As) Log amplitude of primordial fluctuations [2.5, 3.5] ns ns Scalar spectral index [0.88, 1.05] H0 H\u2080 Hubble constant [km/s/Mpc] [40, 100] \u03c9b \u03a9bh\u00b2 Physical baryon density [0.019, 0.025] \u03c9c \u03a9ch\u00b2 Physical CDM density [0.08, 0.20] \u03c4 \u03c4 Optical depth to reionization [0.02, 0.12]"},{"location":"user_guide/overview/#available-spectra","title":"Available Spectra","text":"<p>JaxCapse provides emulators for:</p> <ul> <li>TT: Temperature auto-correlation</li> <li>EE: E-mode polarization auto-correlation</li> <li>TE: Temperature-E-mode cross-correlation</li> <li>PP: Lensing potential auto-correlation</li> </ul>"},{"location":"user_guide/overview/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"user_guide/overview/#speed-benchmarks","title":"Speed Benchmarks","text":"Operation Time Notes Single evaluation ~50 \u03bcs After JIT compilation First evaluation ~1 ms Includes JIT compilation Gradient (6 params) ~400 \u03bcs Using automatic differentiation Batch (1000 samples) ~10 ms Vectorized computation"},{"location":"user_guide/overview/#memory-usage","title":"Memory Usage","text":"<ul> <li>Single emulator: ~10 MB</li> <li>All four emulators: ~40 MB</li> <li>Batch processing scales linearly with batch size</li> </ul>"},{"location":"user_guide/overview/#key-features","title":"Key Features","text":""},{"location":"user_guide/overview/#1-jit-compilation","title":"1. JIT Compilation","text":"<p>Functions are compiled on first use for optimal performance: <pre><code>@jax.jit\ndef fast_computation(params):\n    return emulator.get_Cl(params)\n</code></pre></p>"},{"location":"user_guide/overview/#2-automatic-differentiation","title":"2. Automatic Differentiation","text":"<p>Compute gradients without finite differences: <pre><code>grad_fn = jax.grad(lambda p: jnp.sum(emulator.get_Cl(p)))\n</code></pre></p>"},{"location":"user_guide/overview/#3-vectorization","title":"3. Vectorization","text":"<p>Process multiple parameter sets efficiently: <pre><code>vmap_fn = jax.vmap(emulator.get_Cl)\n</code></pre></p>"},{"location":"user_guide/overview/#4-gpu-acceleration","title":"4. GPU Acceleration","text":"<p>Automatically uses GPU if available: <pre><code>print(jax.devices())  # Check available devices\n</code></pre></p>"},{"location":"user_guide/overview/#best-practices","title":"Best Practices","text":"<ol> <li>Stay Within Bounds: Keep parameters within training ranges</li> <li>Use JAX Arrays: Always pass JAX arrays, not Python lists</li> <li>Batch When Possible: Process multiple cosmologies together</li> <li>Reuse Compiled Functions: JIT compilation happens once per shape</li> </ol>"},{"location":"user_guide/overview/#common-use-cases","title":"Common Use Cases","text":"<ul> <li>Parameter Estimation: MCMC sampling with fast likelihood evaluation</li> <li>Fisher Forecasting: Compute derivatives for Fisher matrix analysis</li> <li>Sensitivity Analysis: Explore parameter dependencies</li> <li>Optimization: Find best-fit cosmological parameters</li> </ul>"},{"location":"user_guide/overview/#limitations","title":"Limitations","text":"<ul> <li>Fixed cosmological model (\u039bCDM with massless neutrinos)</li> <li>Limited parameter ranges (training bounds)</li> <li>Fixed \u2113 range (typically \u2113 = 2 to 5000)</li> <li>No non-linear corrections at very small scales</li> </ul>"},{"location":"user_guide/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Loading Emulators: How to load and configure emulators</li> <li>Computing Spectra: Detailed computation guide</li> <li>Batch Processing: Efficient multi-cosmology processing</li> <li>JAX Features: Advanced JAX functionality</li> </ul>"}]}