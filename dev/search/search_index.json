{"config":{"lang":["en"],"separator":"[\\s\\-\\.]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"jaxcapse","text":"<p>Fast, differentiable CMB power spectrum emulation in JAX</p>"},{"location":"#overview","title":"Overview","text":"<p>jaxcapse is a JAX implementation of the <code>Capse.jl</code> (CMB Angular Power Spectrum Emulator) neural network emulator for computing CMB power spectra. It provides:</p> <ul> <li>\u26a1 Fast inference: Compute CMB power spectra in microseconds</li> <li>\ud83c\udfaf High accuracy: Sub-percent precision across a wide parameter range</li> <li>\ud83d\udd04 Automatic differentiation: Compute gradients/jacobians with respect to cosmological parameters</li> <li>\ud83d\ude80 Batch processing: Efficiently process multiple parameter sets simultaneously</li> <li>\ud83d\udd27 JAX integration: Full compatibility with JAX transformations (JIT, vmap, grad)</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"#speed","title":"Speed","text":"<p>jaxcapse computes CMB power spectra orders of magnitude faster than traditional Boltzmann solvers:</p> <ul> <li>Single evaluation: ~50 \u03bcs</li> <li>Gradient computation: ~400 \u03bcs</li> <li>Batch of 1000: ~10 ms</li> </ul>"},{"location":"#differentiability","title":"Differentiability","text":"<p>Leverage JAX's automatic differentiation for:</p> <ul> <li>Parameter estimation</li> <li>Fisher matrix computation</li> <li>Sensitivity analysis</li> <li>Gradient-based optimization</li> </ul>"},{"location":"#supported-spectra","title":"Supported Spectra","text":"<p>jaxcapse provides trained emulators for:</p> <ul> <li>TT: Temperature-Temperature</li> <li>EE: E-mode polarization</li> <li>TE: Temperature-E-mode cross-correlation</li> <li>PP: Lensing potential</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import jaxcapse\nimport jax.numpy as jnp\n\n# Load a trained emulator\nemulator_TT = jaxcapse.load_emulator(\"trained_emu/TT/\")\n\n# Define cosmological parameters\n# [ln10As, ns, H0, \u03c9b, \u03c9c, \u03c4]\nparams = jnp.array([3.1, 0.96, 67.0, 0.022, 0.12, 0.055])\n\n# Compute power spectrum\ncl_TT = emulator_TT.get_Cl(params)\n\n# Compute jacobians\nimport jax\njacobian = jax.jacfwd(emulator_TT.get_Cl)(params)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install jaxcapse\n</code></pre> <p>Or install from source:</p> <pre><code>git clone https://github.com/CosmologicalEmulators/jaxcapse.git\ncd jaxcapse\npip install -e .\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>API Reference: Complete API documentation</li> <li>Contributing: Contributing guidelines</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python \u2265 3.10</li> <li>JAX \u2265 0.4.30</li> <li>Flax \u2265 0.10.0</li> <li>jaxace \u2265 0.1.1</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use jaxcapse in your research, please cite:</p> <pre><code>@article{Bonici2024Capse,\n    author = {Bonici, Marco and Bianchini, Federico and Ruiz-Zapatero, Jaime},\n    journal = {The Open Journal of Astrophysics},\n    doi = {10.21105/astro.2307.14339},\n    year = {2024},\n    month = {jan 30},\n    publisher = {Maynooth Academic Publishing},\n    title = {Capse.jl: efficient and auto-differentiable {CMB} power spectra emulation},\n    volume = {7},\n}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>jaxcapse is released under the MIT License. See LICENSE for details.</p>"},{"location":"#acknowledgments","title":"Acknowledgments","text":"<p>jaxcapse builds on:</p> <ul> <li>jaxace: JAX implementation of AbstractCosmologicalEmulators.jl</li> <li>Capse.jl: Original Julia implementation</li> <li>JAX: Composable transformations of Python+NumPy programs</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#core-module","title":"Core Module","text":""},{"location":"api/#jaxcapse.jaxcapse","title":"jaxcapse.jaxcapse","text":""},{"location":"api/#jaxcapse.jaxcapse.MLP","title":"MLP","text":"<pre><code>MLP(emulator: FlaxEmulator, in_MinMax: ndarray, out_MinMax: ndarray, postprocessing: callable, emulator_description: Dict[str, Any])\n</code></pre> <p>CAPSE MLP emulator using jaxace infrastructure.</p> <p>This class wraps a jaxace FlaxEmulator with CAPSE-specific functionality for CMB power spectrum computation.</p> <p>Initialize MLP with jaxace emulator and CAPSE-specific components.</p> <p>Parameters:</p> Name Type Description Default <code>emulator</code> <code>FlaxEmulator</code> <p>jaxace FlaxEmulator instance</p> required <code>in_MinMax</code> <code>ndarray</code> <p>Input normalization parameters</p> required <code>out_MinMax</code> <code>ndarray</code> <p>Output normalization parameters</p> required <code>postprocessing</code> <code>callable</code> <p>Postprocessing function (must be JAX-compatible)</p> required <code>emulator_description</code> <code>Dict[str, Any]</code> <p>Emulator metadata</p> required"},{"location":"api/#jaxcapse.jaxcapse.MLP.get_Cl","title":"get_Cl","text":"<pre><code>get_Cl(input_data: ndarray) -&gt; jnp.ndarray\n</code></pre> <p>Compute CMB power spectrum Cl values with JIT compilation.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ndarray</code> <p>Cosmological parameters as JAX array</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Processed Cl values</p>"},{"location":"api/#jaxcapse.jaxcapse.MLP.get_Cl_batch","title":"get_Cl_batch","text":"<pre><code>get_Cl_batch(input_batch: ndarray) -&gt; np.ndarray\n</code></pre> <p>Compute CMB power spectrum Cl values for a batch of inputs using vectorization.</p> <p>Parameters:</p> Name Type Description Default <code>input_batch</code> <code>ndarray</code> <p>Array of cosmological parameters, shape (n_samples, n_params)</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Array of processed Cl values, shape (n_samples, n_cls)</p>"},{"location":"api/#jaxcapse.jaxcapse.MLP.predict","title":"predict","text":"<pre><code>predict(input_data: ndarray) -&gt; jnp.ndarray\n</code></pre> <p>Alias for get_Cl to maintain compatibility with tests and examples.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>ndarray</code> <p>Cosmological parameters as JAX array</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Processed Cl values</p>"},{"location":"api/#jaxcapse.jaxcapse.load_emulator","title":"load_emulator","text":"<pre><code>load_emulator(folder_path: str) -&gt; MLP\n</code></pre> <p>Load a CAPSE emulator using jaxace infrastructure.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>Path to the emulator folder containing: - nn_setup.json: Neural network specification - weights.npy: Trained weights - inminmax.npy: Input normalization parameters - outminmax.npy: Output normalization parameters - postprocessing.py: Postprocessing function</p> required <p>Returns:</p> Type Description <code>MLP</code> <p>MLP instance ready for inference</p>"},{"location":"api/#jaxcapse.jaxcapse.load_preprocessing","title":"load_preprocessing","text":"<pre><code>load_preprocessing(root_path: str, filename: str) -&gt; callable\n</code></pre> <p>Load postprocessing function from Python file.</p> <p>Parameters:</p> Name Type Description Default <code>root_path</code> <code>str</code> <p>Directory containing the postprocessing file</p> required <code>filename</code> <code>str</code> <p>Name of the postprocessing file (without .py extension)</p> required <p>Returns:</p> Type Description <code>callable</code> <p>The postprocessing function</p>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to jaxcapse! This document provides guidelines for contributing to the project.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork the repository</li> <li>Clone your fork: <code>git clone https://github.com/yourusername/jaxcapse.git</code></li> <li>Install in development mode: <code>pip install -e \".[dev]\"</code></li> <li>Create a new branch: <code>git checkout -b feature-name</code></li> </ol>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Run tests before submitting: <pre><code>pytest tests/\n</code></pre></p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Build documentation locally: <pre><code>mkdocs build\nmkdocs serve  # Preview at http://localhost:8000\n</code></pre></p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure all tests pass</li> <li>Update documentation if needed</li> <li>Add tests for new functionality</li> <li>Submit pull request to <code>develop</code> branch</li> </ol>"},{"location":"usage_examples/","title":"Usage Examples","text":"<p>This guide demonstrates how to use jaxcapse to compute and visualize CMB power spectra and their derivatives.</p>"},{"location":"usage_examples/#quick-start","title":"Quick Start","text":"<pre><code>import jaxcapse\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\n\n# The emulators are automatically loaded when you import jaxcapse\n# Access them via the trained_emulators dictionary\nemulators = jaxcapse.trained_emulators[\"camb_lcdm\"]\n</code></pre>"},{"location":"usage_examples/#computing-power-spectra","title":"Computing Power Spectra","text":""},{"location":"usage_examples/#basic-usage","title":"Basic Usage","text":"<pre><code># Define cosmological parameters\n# Order: [omega_b, omega_c, h, ln10As, ns, tau]\nparams = jnp.array([\n    0.02237,   # Baryon density\n    0.1200,    # CDM density\n    0.6736,    # Hubble parameter\n    3.044,     # Log primordial amplitude\n    0.9649,    # Spectral index\n    0.0544     # Optical depth\n])\n\n# Compute all power spectra\ncl_tt = emulators[\"TT\"].predict(params)  # Temperature\ncl_ee = emulators[\"EE\"].predict(params)  # E-mode polarization\ncl_te = emulators[\"TE\"].predict(params)  # Temperature-polarization cross\ncl_pp = emulators[\"PP\"].predict(params)  # Lensing potential\n</code></pre>"},{"location":"usage_examples/#plotting-all-spectra","title":"Plotting All Spectra","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# Create multipole array (adjust based on your emulator output)\nn_ells = len(cl_tt)\nell = np.arange(2, n_ells + 2)\n\n# Create figure with subplots for all spectra\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\n# Plot TT spectrum\naxes[0, 0].loglog(ell, ell * (ell + 1) * cl_tt / (2 * np.pi))\naxes[0, 0].set_xlabel(r'$\\ell$')\naxes[0, 0].set_ylabel(r'$\\ell(\\ell+1)C_\\ell^{TT}/2\\pi$ [$\\mu K^2$]')\naxes[0, 0].set_title('Temperature Power Spectrum')\naxes[0, 0].grid(True, alpha=0.3)\n\n# Plot EE spectrum\naxes[0, 1].loglog(ell, ell * (ell + 1) * cl_ee / (2 * np.pi))\naxes[0, 1].set_xlabel(r'$\\ell$')\naxes[0, 1].set_ylabel(r'$\\ell(\\ell+1)C_\\ell^{EE}/2\\pi$ [$\\mu K^2$]')\naxes[0, 1].set_title('E-mode Polarization Spectrum')\naxes[0, 1].grid(True, alpha=0.3)\n\n# Plot TE spectrum (can be negative, use semilogy with abs)\ncl_te_plot = ell * (ell + 1) * np.abs(cl_te) / (2 * np.pi)\naxes[1, 0].loglog(ell, cl_te_plot)\naxes[1, 0].set_xlabel(r'$\\ell$')\naxes[1, 0].set_ylabel(r'$|\\ell(\\ell+1)C_\\ell^{TE}/2\\pi|$ [$\\mu K^2$]')\naxes[1, 0].set_title('Temperature-Polarization Cross Spectrum')\naxes[1, 0].grid(True, alpha=0.3)\n\n# Plot PP spectrum (lensing potential)\naxes[1, 1].loglog(ell, ell * (ell + 1) * cl_pp)\naxes[1, 1].set_xlabel(r'$\\ell$')\naxes[1, 1].set_ylabel(r'$\\ell(\\ell+1)C_\\ell^{\\phi\\phi}$')\naxes[1, 1].set_title('Lensing Potential Spectrum')\naxes[1, 1].grid(True, alpha=0.3)\n\nplt.tight_layout()\nplt.savefig('cmb_spectra.png', dpi=150, bbox_inches='tight')\nplt.show()\n</code></pre>"},{"location":"usage_examples/#computing-jacobians-with-jax","title":"Computing Jacobians with JAX","text":"<p>One of the powerful features of jaxcapse is that the emulators are fully differentiable using JAX's automatic differentiation.</p>"},{"location":"usage_examples/#basic-jacobian-computation","title":"Basic Jacobian Computation","text":"<pre><code>import jax\nimport jax.numpy as jnp\n\n# Define a function that computes TT spectrum from parameters\ndef compute_cl_tt(params):\n    \"\"\"Compute TT power spectrum for given parameters.\"\"\"\n    return emulators[\"TT\"].predict(params)\n\n# Compute Jacobian using JAX autodiff\njacobian_fn = jax.jacobian(compute_cl_tt)\njacobian = jacobian_fn(params)\n\nprint(f\"Jacobian shape: {jacobian.shape}\")\n# Output: (n_ell, n_params) - derivative of each Cl with respect to each parameter\n</code></pre>"},{"location":"usage_examples/#visualizing-parameter-sensitivities","title":"Visualizing Parameter Sensitivities","text":"<pre><code># Parameter names for labeling\nparam_names = [r'$\\omega_b$', r'$\\omega_c$', r'$h$',\n               r'$\\ln(10^{10}A_s)$', r'$n_s$', r'$\\tau$']\n\n# Create figure showing Jacobian for each parameter\nfig, axes = plt.subplots(2, 3, figsize=(15, 10))\naxes = axes.flatten()\n\nfor i, (ax, name) in enumerate(zip(axes, param_names)):\n    # Plot derivative of Cl_TT with respect to parameter i\n    ax.semilogx(ell, jacobian[:, i])\n    ax.set_xlabel(r'$\\ell$')\n    ax.set_ylabel(rf'$\\partial C_\\ell^{{TT}}/\\partial {name}$')\n    ax.set_title(f'Sensitivity to {name}')\n    ax.grid(True, alpha=0.3)\n    ax.axhline(0, color='k', linestyle='--', alpha=0.5)\n\nplt.suptitle('CMB TT Power Spectrum Jacobian', fontsize=16)\nplt.tight_layout()\nplt.savefig('jacobian_tt.png', dpi=150, bbox_inches='tight')\nplt.show()\n</code></pre>"},{"location":"usage_examples/#complete-example-script","title":"Complete Example Script","text":"<p>Here's a complete script that generates all the plots:</p> <pre><code>import jaxcapse\nimport jax\nimport jax.numpy as jnp\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Set up parameters\nparams = jnp.array([0.02237, 0.1200, 0.6736, 3.044, 0.9649, 0.0544])\nparam_names = [r'$\\omega_b$', r'$\\omega_c$', r'$h$',\n               r'$\\ln(10^{10}A_s)$', r'$n_s$', r'$\\tau$']\n\n# Get emulators\nemulators = jaxcapse.trained_emulators[\"camb_lcdm\"]\n\n# Compute all spectra\ncl_tt = emulators[\"TT\"].predict(params)\ncl_ee = emulators[\"EE\"].predict(params)\ncl_te = emulators[\"TE\"].predict(params)\ncl_pp = emulators[\"PP\"].predict(params)\n\n# Create ell array\nn_ells = len(cl_tt)\nell = np.arange(2, n_ells + 2)\n\n# Plot all spectra\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n# ... (plotting code as shown above)\n\n# Compute and plot Jacobian\njacobian_fn = jax.jacobian(emulators[\"TT\"].predict)\njacobian = jacobian_fn(params)\n\nfig, axes = plt.subplots(2, 3, figsize=(15, 10))\n# ... (Jacobian plotting code as shown above)\n\nprint(\"All plots generated successfully!\")\n</code></pre>"},{"location":"usage_examples/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ol> <li>Parameter ranges: Keep parameters within training ranges for accurate predictions</li> <li>JIT compilation: Use <code>@jax.jit</code> for repeated evaluations</li> <li>Batch processing: Use <code>vmap</code> for multiple parameter sets</li> <li>Gradient checks: Verify Jacobians have expected physical behavior</li> <li>Memory management: Emulators are loaded once at import</li> </ol>"},{"location":"examples/data_management/","title":"Data Management","text":"<p>The <code>jaxcapse</code> package includes a simple data fetcher for downloading and caching trained emulator files from Zenodo.</p>"},{"location":"examples/data_management/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/data_management/#loading-an-emulator","title":"Loading an Emulator","text":"<p>The simplest way to load an emulator is using the pre-loaded emulators:</p> <pre><code>import jaxcapse\n\n# Emulators are automatically downloaded and loaded on import\n# Access them from the trained_emulators dictionary\nemulator_TT = jaxcapse.trained_emulators[\"camb_lcdm\"][\"TT\"]\nemulator_EE = jaxcapse.trained_emulators[\"camb_lcdm\"][\"EE\"]\n\n# Or load from a specific path\nfrom jaxcapse import get_emulator_path, load_emulator\npath = get_emulator_path(\"TT\")  # Returns path to TT emulator\nemulator = load_emulator(str(path))\n</code></pre>"},{"location":"examples/data_management/#checking-available-emulators","title":"Checking Available Emulators","text":"<pre><code>from jaxcapse.data_fetcher import get_fetcher\n\nfetcher = get_fetcher()\n\n# List all available emulators\navailable = fetcher.list_available()\nfor name, description in available.items():\n    print(f\"{name}: {description}\")\n\n# List cached emulators\ncached = fetcher.list_cached()\nprint(f\"Cached emulators: {cached}\")\n</code></pre>"},{"location":"examples/data_management/#advanced-usage","title":"Advanced Usage","text":""},{"location":"examples/data_management/#custom-cache-directory","title":"Custom Cache Directory","text":"<pre><code>from jaxcapse.data_fetcher import EmulatorDataFetcher\n\n# Use a custom cache directory\nfetcher = EmulatorDataFetcher(\n    zenodo_url=\"https://zenodo.org/records/17115001/files/trained_emu.tar.gz?download=1\",\n    emulator_types=[\"TT\", \"TE\", \"EE\", \"PP\"],\n    cache_dir=\"/path/to/my/cache\",\n    expected_checksum=\"b1d6f47c3bafb6b1ef0b80069e3d7982f274c6c7352ee44e460ffb9c2a573210\"\n)\n\n# Load a specific emulator\nemulator_path = fetcher.get_emulator_path(\"TT\")\n</code></pre>"},{"location":"examples/data_management/#adding-new-emulator-configurations","title":"Adding New Emulator Configurations","text":"<p>When you upload new emulator files to Zenodo, you can add them to jaxcapse:</p> <pre><code>from jaxcapse import add_emulator_config\n\n# Add a new emulator configuration\nadd_emulator_config(\n    model_name=\"my_custom_model\",\n    zenodo_url=\"https://zenodo.org/record/1234567/files/my_emulators.tar.gz\",\n    emulator_types=[\"TT\", \"EE\"],\n    description=\"My custom LCDM emulators\",\n    checksum=\"abc123...\",  # Optional SHA256 checksum\n    auto_load=True  # Automatically download and load\n)\n\n# Access the newly loaded emulators\nemulator_TT = jaxcapse.trained_emulators[\"my_custom_model\"][\"TT\"]\n</code></pre>"},{"location":"examples/data_management/#manual-download-control","title":"Manual Download Control","text":"<pre><code>from jaxcapse.data_fetcher import get_fetcher\n\nfetcher = get_fetcher()\n\n# Get path without downloading\npath = fetcher.get_emulator_path(\"TT\", download_if_missing=False)\nif path is None:\n    print(\"Emulator not cached\")\n\n# Force download even if cached\nsuccess = fetcher.download_and_extract(force=True, show_progress=True)\n</code></pre>"},{"location":"examples/data_management/#cache-management","title":"Cache Management","text":"<pre><code># Clear specific emulator from cache\nfetcher.clear_cache(\"TT\")  # Clear TT emulator\n\n# Clear all cached files\nfetcher.clear_cache()  # Clear everything\n</code></pre>"},{"location":"examples/data_management/#example-computing-cl-jacobians","title":"Example: Computing Cl Jacobians","text":"<p>Here's a complete example that downloads emulator data and computes Jacobians:</p> <pre><code>import jax\nimport jax.numpy as jnp\nimport jaxcapse\n\n# Access the pre-loaded TT emulator\nemulator_TT = jaxcapse.trained_emulators[\"camb_lcdm\"][\"TT\"]\n\n# Define cosmological parameters\n# Order: omega_b, omega_c, h, ln10As, ns, tau\nfiducial_params = jnp.array([0.02237, 0.1200, 0.6736, 3.044, 0.9649, 0.0544])\n\n# The emulator has a predict method that works with JAX\ncl_tt = emulator_TT.predict(fiducial_params)\n\n# Compute Jacobian using JAX autodiff\njacobian_fn = jax.jacobian(emulator_TT.predict)\njacobian = jacobian_fn(fiducial_params)\n\n# jacobian shape: (n_ell, n_params)\nprint(f\"Cl shape: {cl_tt.shape}\")\nprint(f\"Jacobian shape: {jacobian.shape}\")\n\n# Example: sensitivity at ell=100\nell_index = 100\nparam_names = ['omega_b', 'omega_c', 'h', 'ln10As', 'ns', 'tau']\nprint(f\"\\nParameter sensitivities at ell={ell_index}:\")\nfor i, param in enumerate(param_names):\n    print(f\"  \u2202Cl/\u2202{param:8s} = {jacobian[ell_index, i]:+.3e}\")\n</code></pre>"},{"location":"examples/data_management/#configuration-for-cicd","title":"Configuration for CI/CD","text":"<p>For GitHub Actions or other CI systems, you can set up automatic data fetching:</p> <pre><code># .github/workflows/docs.yml\n- name: Cache emulator data\n  uses: actions/cache@v3\n  with:\n    path: ~/.jaxcapse_data\n    key: emulator-data-${{ hashFiles('**/pyproject.toml') }}\n    restore-keys: |\n      emulator-data-\n\n- name: Download emulator data\n  run: |\n    python -c \"\n    from jaxcapse.data_fetcher import get_fetcher\n    fetcher = get_fetcher()\n    # Pre-download all emulators\n    fetcher.download_and_extract(show_progress=True)\n    \"\n</code></pre>"},{"location":"examples/data_management/#setting-up-your-own-zenodo-dataset","title":"Setting Up Your Own Zenodo Dataset","text":"<ol> <li>Upload your emulator files to Zenodo:</li> <li>Go to Zenodo</li> <li>Create a new upload</li> <li>Package your emulator files as a tar.gz archive</li> <li> <p>Publish to get a DOI and download URL</p> </li> <li> <p>Add your emulators to jaxcapse: <pre><code>from jaxcapse import add_emulator_config\n\n# Use the direct tar.gz download URL from Zenodo\nadd_emulator_config(\n    model_name=\"my_model\",\n    zenodo_url=\"https://zenodo.org/record/XXXXX/files/my_emulators.tar.gz\",\n    emulator_types=[\"TT\", \"EE\", \"TE\", \"PP\"],\n    description=\"My custom emulators\"\n)\n</code></pre></p> </li> <li> <p>Optional: Add checksum for verification: <pre><code># Generate SHA256 checksum\nsha256sum my_emulators.tar.gz\n</code></pre></p> </li> </ol> <p>Then include it:    <pre><code>add_emulator_config(\n    model_name=\"my_model\",\n    zenodo_url=\"https://zenodo.org/record/XXXXX/files/my_emulators.tar.gz\",\n    emulator_types=[\"TT\", \"EE\", \"TE\", \"PP\"],\n    checksum=\"abc123def456...\",\n    auto_load=True\n)\n</code></pre></p>"}]}